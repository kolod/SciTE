<HTML><HEAD><TITLE>Перекодировщик xcode Д.В.Хмелёв</TITLE><BASE target=_top>
<META content="MSHTML 6.00.3790.0" name=GENERATOR></HEAD>
<BODY>
<TABLE cellSpacing=0 cellPadding=0 border=0>
<TBODY>
<TR>
<TD width=600>
<H1 align=center>Перекодировщик xcode </H1>
<H3 align=center>Д.В.Хмелёв </H3>
<P>
<H1>Содержание </H1><A href="#tth_sEc1">1&nbsp; Зачем нужен ещё один перекодировщик?</A><BR><A href="#tth_sEc2">2&nbsp; Установка и компиляция</A><BR><A href="#tth_sEc3">3&nbsp; Особенности использования</A><BR><A href="#tth_sEc4">4&nbsp; Применения</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.1">4.1&nbsp; Сортировка</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.2">4.2&nbsp; Внутренний перекодировщик</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.3">4.3&nbsp; Фильтр на входной почте</A><BR><A href="#tth_sEc5">5&nbsp; О перестановочной кодировке и iconv</A><BR><A href="#tth_sEc6">6&nbsp; Лог изменений программы</A><BR><A href="#tth_sEc7">7&nbsp; Награды программы</A><BR><A href="#tth_sEc8">8&nbsp; Лицензия Ё-ware</A><BR><A href="#tth_sEc9">9&nbsp; Дополнительные вопросы</A><BR>
<P>
<H2><A name=tth_sEc1>1</A>&nbsp;&nbsp;Зачем нужен ещё один перекодировщик?</H2>В природе существует <EM>очень много</EM> программ, которые перекодируют между разными кодировками кириллического алфавита. Эти функции встроены в специализированные HTML-редакторы, в драйверы клавиатуры и т.п. Тем не менее, анализ существующего положения дел показывает, что все эти способы страдают хотя бы одним из перечисленных ниже изъянов: 
<P>
<OL type=1>
<P>
<LI>Необратимость перекодировки<A href="#tthFtNtAAB" name=tthFrefAAB><SUP>1</SUP></A>. 
<P></P>
<LI>Неаккуратность с буквой Ё. 
<P></P>
<LI>Необходимость явного выбора кодировки. 
<P></P>
<LI>Небольшой набор кодировок. 
<P></P>
<LI>Работа только под какой-либо определённой платформой (Win32, DOS, и т.п.) 
<P></P>
<LI>Сложности с применением в пакетном режиме (как, например, перекодировать все файлы в поддиректории в заданную кодировку, независимо от исходной?) 
<P></P>
<LI>Объём перекодируемого файла ограничен оперативной памятью. 
<P></P>
<LI>Отсутствие режима командной строки. </LI></OL>
<P>Перекодировщик xcode является платформо-независимой программой, которая лишена всех этих недостатков. 
<P>
<OL type=1>
<P>
<LI>Перекодировка обратима. 
<P></P>
<LI>Полная поддержка буквы Ё. 
<P></P>
<LI>Кодировка входного файла определяется автоматически. 
<P></P>
<LI>Поддерживается 14 кодировок, включая стандартные cp866, cp1251, koi8-r, iso8859-5, mac. 
<P></P>
<LI>Код программы написан с использованием ANSI Си и переносим, в принципе, на любую платформу (поддерживаются Win32, DOS, Unix, <A href="http://www.gnu.org/">GNU/Linux</A>). 
<P></P>
<LI>Программа может перекодировать файл на месте, поэтому её можно просто применять ко всем файлам в директории (такая функция заложена в любом современном менеджере файлов: Far, WinCommander и т.д.) 
<P></P>
<LI>Объём перекодируемого файла ограничен только свободным местом на жёстком диске. 
<P></P>
<LI>Интерфейс командной строки. </LI></OL>
<P>Кроме этого 
<P>
<UL>
<P>
<LI>можно декодировать quoted-printable, 
<P></P>
<LI>можно декодировать HTML-Unicode текст вроде «&amp;#1044;&amp;#1080;&amp;#1084;&amp;#1072;», 
<P></P>
<LI>можно использовать режим трубы, 
<P></P>
<LI>имеется специальная сортировочная кодировка, позволяющая корректно сортировать файлы с буквой Ё стандартными средствами операционной системы (нелокализованными!), 
<P></P>
<LI>интерфейс на русском/английском языках, 
<P></P>
<LI>устойчивость текста программы к <EM>корректной</EM> перекодировке, 
<P></P>
<LI>текст программы хранится в одном файле, что обеспечивает его целостность при перемещении между компьютерами. </LI></UL>
<P>Разумеется, <TT>xcode</TT> не отменяет имеющиеся перекодировщики в редакторах. Он просто является мощным и полезным добавлением для пакетной обработки данных. 
<P>
<H2><A name=tth_sEc2>2</A>&nbsp;&nbsp;Установка и компиляция</H2><A name=s:setup_and_compile></A>Текущая версия программы: <B>xcode 4.1</B>. 
<P><B>Исходный текст</B> <A href="http://www.rusf.ru/books/yo/src/xcodesrc.zip"><TT>./src/xcodesrc.zip</TT></A> 
<P>Программа доступна под следующие операционные системы: 
<P><B>DOS</B> <A href="http://www.rusf.ru/books/yo/bin/xcodedos.zip"><TT>./bin/xcodedos.zip</TT></A> Рекомендуется скопировать программу в одну из директорий, находящихся в переменной окружения PATH. 
<P><B>Win</B> <A href="http://www.rusf.ru/books/yo/bin/xcodewin.zip"><TT>./bin/xcodewin.zip</TT></A> Рекомендуется скопировать программу в %WINDOWS%\COMMAND (что часто совпадает с C:\WINDOWS\COMMAND). Эта версия отличается от версии для DOS и скомпилирована как консольное приложение win32. 
<P><B>Unix</B> <A href="http://www.rusf.ru/books/yo/bin/linux.zip"><TT>./bin/linux.zip</TT></A> Должна работать под всеми современными дистрибутивами Линукса (программа была откомпилирована под SuSE 8.1) <A href="http://www.rusf.ru/books/yo/bin/xcoderedhat71.zip"><TT>./bin/xcoderedhat71.zip</TT></A> для RedHat 7.1 (больше не поддерживается, компилируйте исходник) <A href="http://www.rusf.ru/books/yo/bin/xcodesun.zip"><TT>./bin/xcodesun.zip</TT></A> для Sun Solaris 8 (больше не поддерживается, компилируйте исходник). 
<P>При компиляции программы&nbsp;<A href="http://www.rusf.ru/books/yo/src/xcodesrc.zip">xcode.c</A> определите параметр <TT>D_KOI</TT> (<TT>D_ALT</TT> или <TT>D_WIN</TT>), определяющий вывод на экран в кодировке <B>koi8-r</B> (<B>cp866</B> или <B>cp1251</B>, соответственно). Например так: <PRE>   gcc xcode.c -DD_KOI -O3 -o xcode

</PRE>Но можно расскоментировать соответствующий <TT>#define</TT> прямо в тексте программы (эти определения находятся на первой странице листинга). 
<P>Теперь скопируйте выполнимый xcode (xcode.exe в DOS/Win32) в одну из директорий, перечисленных в системной переменной <TT>PATH</TT>. Под Win95/98 хорошим местом будет директория <TT>%WINDOWS%COMMAND</TT> (которая обычно маскируется под <TT>C:\WINDOWS\COMMAND</TT>). Под Юниксом станадартная директория для таких программ: <TT>/usr/local/bin/</TT> (если доступны права рута) или просто домашняя директория (если права рута недоступны). 
<P>Программа xcode является Ё-ware, см лицензию в разделе&nbsp;<A href="#l:license">8</A>. 
<P>
<H2><A name=tth_sEc3>3</A>&nbsp;&nbsp;Особенности использования</H2>Для использования программы вам требуется перейти в режим командной строки, имеющийся в любом файловом менеджере под DOS/Win, и в любой консоли под Unix. Справка по программе выводится при наборе <PRE>  xcode -h

</PRE>Если требуется перекодировать файл <TT>text.txt</TT>, из кодировки cp866 в кодировку cp1251, запустите <PRE>  xcode -w text.txt text.txt

</PRE>После запуска команды вы получите сообщения вроде <PRE>Угадана входная кодировка cp866
Выходная кодировка cp1251

</PRE>Теперь перекодируем текст в кодировку koi8: <PRE>  xcode -k text.txt text.txt

Угадана входная кодировка cp1251
Выходная кодировка koi8-r

</PRE>и, наконец, обратно в cp866: <PRE>  xcode -a text.txt text.txt

Угадана входная кодировка koi8-r
Выходная кодировка cp866

</PRE>
<P>Обратите внимание, что ни разу не потребовалось указать кодировку файла, подлежащего преобразованию. Кроме того <EM>обратимость перекодировки</EM> xcode обеспечивает, что получившийся файл text.txt идентичен самому себе до преобразования, <EM>даже если text.txt</EM> содержал символы из верхней части таблицы, не принадлежавшие алфавиту. Обратите внимание, что аналогичный фокус не пройдёт, например, с распространённой программой recode, поскольку она не обеспечивает <EM>обратимости перекодировки</EM>. Приведённый выше пример с явным указанием кодировки выглядит так: <PRE> xcode +a -w text.txt text.txt

В качестве входной установлена кодировка cp866
Выходная кодировка cp1251

 xcode +w -k text.txt text.txt

В качестве входной установлена кодировка cp1251
Выходная кодировка koi8-r

 xcode +k -a text.txt text.txt

В качестве входной установлена кодировка koi8-r
Выходная кодировка cp866

</PRE>Таким образом переключатель <TT>+</TT> означает выбор кодировки у исходного текста. Аналогичный сеанс с recode выглядел бы так: 
<P><PRE> recode -aw text.txt text.txt
 recode -wk text.txt text.txt
 recode -ka text.txt text.txt

</PRE>При этом неалфавитные символы из верхней части таблицы ASCII (см. раздел&nbsp;<A href="http://www.rusf.ru/books/yo/encoding.html">Кодировки</A>) скорее всего безвозвратно перемешаются с символами алфавита. Если же кодировка исходного файла text.txt была отлична от cp866, то текст в файле text.txt скорее всего потеряется в результате такой перекодировки безвозвратно. 
<P>Таким образом, главное преимущество <TT>xcode</TT> перед остальными программами: надёжность в сохранении данных. Самое худшее, что может случиться - это неверная перестановка букв, которую при желании всегда можно обратить. 
<P>
<H2><A name=tth_sEc4>4</A>&nbsp;&nbsp;Применения</H2>
<H3><A name=tth_sEc4.1>4.1</A>&nbsp;&nbsp;Сортировка</H3>Программу <A href="http://www.rusf.ru/books/yo/src/xcodesrc.zip">xcode.c</A> можно применять для <EM>корректной</EM> сортировки данных по алфавиту. Для этого надо перекодировать текст в кодировку <B>sorted</B> (см. статью&nbsp;<A href="http://www.rusf.ru/books/yo/encoding.html">Кодировки</A>). 
<P>Типичный пример сортировки под Юниксом, сортирующий строки файла <TT>text.txt</TT> и выводящий результат в файл <TT>sorted</TT> 
<P><PRE>xcode -8 &lt;text.txt | LANG= LC_COLLATE= sort\
 | xcode +8 &gt;sorted.txt

</PRE>
<P>Заметим, что мы здесь «обнулили» локаль с помощью команд <TT>LANG=</TT> <TT>LC_COLLATE=</TT>. Такой подход позволяет сортировать тексты даже на нелокализованных системах (в частности, под DOS, где понятие локали отсутствует вообще). 
<P>Пример команд, сортирующих строки файла под ДОС: 
<P><PRE> xcode -8 text.txt text.txt
 sort text.txt &gt;sorted.txt
 xcode +8 sorted.txt sorted.txt

</PRE>
<P>
<H3><A name=tth_sEc4.2>4.2</A>&nbsp;&nbsp;Внутренний перекодировщик</H3>В семействе редакторов VIM, GVIM и т.п., наследующих легендарному VI, <A href="http://www.rusf.ru/books/yo/src/xcodesrc.zip">xcode.c</A> можно применять для автоматической перекодировки текста прямо внутри редактора. Только возможно, придётся запускать <TT>xcode -s -p</TT> в silent-режиме, поскольку некоторые варианты VI «подхватывают» вывод информационных сообщений программы в поток ошибок stderr, что может быть неуместно. 
<P>
<H3><A name=tth_sEc4.3>4.3</A>&nbsp;&nbsp;Фильтр на входной почте</H3>Не знаю как у вас, а когда я читаю почту на сервере с помощью программы PINE, тексты, приходящие в win1251 не перекодируются. Так я поставил <A href="http://www.rusf.ru/books/yo/src/xcodesrc.zip">xcode.c</A> входным фильтром в <TT>.procmailrc</TT> и вот мой рецепт: <PRE>:0:
|/u/dkhmelev/bin/xcode &gt;&gt;$ORGMAIL

</PRE>
<P>
<H2><A name=tth_sEc5>5</A>&nbsp;&nbsp;О перестановочной кодировке и iconv</H2><A name=s:recoding_example></A>
<P><B>Вопрос</B> <EM>Я не очень понял суть перестановочной перекодировки. Протестировав <A href="http://www.rusf.ru/books/yo/xcode.html">xcode</A> на нескольких файлах я заметил, что файлы перекодированные <A href="http://www.rusf.ru/books/yo/xcode.html">xcode</A> и iconv ничем не отличаются (файлы сравнивались при помощи kompare) если в тексте нет псевдографики. На псевдографике iconv сбивается, а <A href="http://www.rusf.ru/books/yo/xcode.html">xcode</A> оставляет в этих местах крякозябры. Как я понял, перестановочная перекодировка заменяет только русские буквы, а все остальные коды оставляет как есть. Правильно? Это единственное отличие от других перекодировщиков?</EM> 
<P>Наоборот. Все подстановочные перекодировщики заменяют <EM>только</EM> русские буквы, а перестановочная кодировка заменяет <EM>все</EM> буквы. 
<P>Попробую объяснить на следующем примере. Пусть вместо 128 кодов в верхней половине кодовой таблицы имеется всего 5 кодов, а буквы занимают на 66 кодов, а 3. И пусть будет две кодировки этих трёх букв: 
<P>
<CENTER>
<TABLE border=1>
<TBODY>
<TR>
<TD align=middle colSpan=6>Кодировка 1</TD></TR>
<TR>
<TD>код</TD>
<TD align=middle>1</TD>
<TD align=middle>2</TD>
<TD align=middle>3</TD>
<TD align=middle>4</TD>
<TD align=middle>5</TD></TR>
<TR>
<TD>буква</TD>
<TD align=middle>А</TD>
<TD align=middle>Б</TD>
<TD align=middle>В</TD>
<TD align=middle>*</TD>
<TD align=middle>*</TD></TR></TBODY></TABLE>
<P>
<TABLE border=1>
<TBODY>
<TR>
<TD align=middle colSpan=6>Кодировка 2</TD></TR>
<TR>
<TD>код</TD>
<TD align=middle>1</TD>
<TD align=middle>2</TD>
<TD align=middle>3</TD>
<TD align=middle>4</TD>
<TD align=middle>5</TD></TR>
<TR>
<TD>буква</TD>
<TD align=middle>*</TD>
<TD align=middle>А</TD>
<TD align=middle>*</TD>
<TD align=middle>Б</TD>
<TD align=middle>В</TD></TR></TBODY></TABLE></CENTER>
<P>То есть, в первой кодировке код А - 1, а во второй код А - 2 и т.д. 
<P>Обычный перекодировщик из первой кодировки во вторую коду 1 сопоставляет код 2, коду 2 коду 4, коду 3, код 5. Коды 4 и 5 остаются на месте. Итого 
<P><BR clear=all>
<TABLE width="100%" border=0>
<TBODY>
<TR>
<TD>
<TABLE align=center>
<TBODY>
<TR>
<TD noWrap align=middle>1 <FONT face=symbol>®</FONT> 2</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P><BR clear=all>
<TABLE width="100%" border=0>
<TBODY>
<TR>
<TD>
<TABLE align=center>
<TBODY>
<TR>
<TD noWrap align=middle>2 <FONT face=symbol>®</FONT> 4</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P><BR clear=all>
<TABLE width="100%" border=0>
<TBODY>
<TR>
<TD>
<TABLE align=center>
<TBODY>
<TR>
<TD noWrap align=middle>3 <FONT face=symbol>®</FONT> 5</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P><BR clear=all>
<TABLE width="100%" border=0>
<TBODY>
<TR>
<TD>
<TABLE align=center>
<TBODY>
<TR>
<TD noWrap align=middle>4 <FONT face=symbol>®</FONT> 4</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P><BR clear=all>
<TABLE width="100%" border=0>
<TBODY>
<TR>
<TD>
<TABLE align=center>
<TBODY>
<TR>
<TD noWrap align=middle>5 <FONT face=symbol>®</FONT> 5</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE>
<P>Очевидно, буквы с кодами 2 и 4 отображаются в один код - 4. Таким образом, если на входе был бинарный файл (содержащий не только символы алфавита, а например, ещё и псевдографику), то он будет испорчен безнадёжно: псевдографика обратится в буквы. 
<P>Это может привести к принципиальной невозможности восстановить исходный текст. 
<P><EM>Перестановочный кодировщик</EM> перекодирует коды 4 и 5 в оставшиеся пустыми коды в образе: 
<P><BR clear=all>
<TABLE width="100%" border=0>
<TBODY>
<TR>
<TD>
<TABLE align=center>
<TBODY>
<TR>
<TD noWrap align=middle>1 <FONT face=symbol>®</FONT> 2</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><BR clear=all>
<TABLE width="100%" border=0>
<TBODY>
<TR>
<TD>
<TABLE align=center>
<TBODY>
<TR>
<TD noWrap align=middle>2 <FONT face=symbol>®</FONT> 4</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><BR clear=all>
<TABLE width="100%" border=0>
<TBODY>
<TR>
<TD>
<TABLE align=center>
<TBODY>
<TR>
<TD noWrap align=middle>3 <FONT face=symbol>®</FONT> 5</TD></TR></TBODY></TABLE></TD></TR></TBODY></TABLE><BR clear=all>
<TABLE width="100%" border=0>
<TBODY>
<TR>
<TD>
<TABLE align=center>
<TBODY>
<TR>
<TD noWrap align=middle>4 <FONT face=symbol>®</FONT> 1</TD></TR></TBODY></TABLE></TD>
<TD width="1%">(*)</TD></TR></TBODY></TABLE><BR clear=all>
<TABLE width="100%" border=0>
<TBODY>
<TR>
<TD>
<TABLE align=center>
<TBODY>
<TR>
<TD noWrap align=middle>5 <FONT face=symbol>®</FONT> 3</TD></TR></TBODY></TABLE></TD>
<TD width="1%">(*)</TD></TR></TBODY></TABLE>
<P>Очевидно, это преобразование обратимо. И даже если мы неверно поняли кодировку исходного файла, всё равно есть шанс её восстановить. Всё что мы теряем в худшем случае - это информацию о перестановке букв, которую восстановить значительно легче, чем текст со слившимися буквами, что частая ситуация, особенно, когда файл в KOI-кодировке перекодируется по ошибке из кодировки WIN в ту же кодировку KOI. 
<P>В заключение отмечу, что проблема с iconv заключается в том, что он пытается установить взаимно-однозначное сопоставление кодировок, которое, к сожалению, не имеет места (скажем, в win-1251 нет псевдографики, хотя в KOI-8 и ALT псевдографика присутствует). Поэтому iconv спотыкается и говорит, что преобразование невозможно. 
<P>
<H2><A name=tth_sEc6>6</A>&nbsp;&nbsp;Лог изменений программы</H2>
<P><PRE>Revision 4.1  2004/02/04 05:32:13  mamont
Добавлен переключатель -c, позволяющий
определять кодировку файла и выдавать её
на экран. Полная справка по -H содержит
инструкции по применению этой новой
возможности. При корректном
использовании переключателя -c программа
выходит с кодом ошибки
6 --- ERROR_INFORM_ENCODING.

Revision 4.0  2003/12/20 23:11:12  mamont
Добавлен ключ -d для определения
двойной перекодировки. Смена номера
версии на 4.0

Revision 3.7  2003/10/05 18:35:21  mamont
Исправлен глюк, возникавший при вызове
  xcode in out
с отсутствующим файлом out (выдавалась
ошибка).

Revision 3.6  2003/10/05 00:15:24  mamont
Заработал прозрачно бинарный стандартный
ввод/вывод под ДОС-окном. Версию mingw
не проверял, но, по идее тоже должна работать.

Revision 3.5  2003/10/04 23:26:25  mamont
Теперь stdout устанавливается в бинарный
режим в DOS/WIN окружении. Иначе
добавлялся код \x0D в конце каждой
строки (\x0D\x0A).

Revision 3.4  2003/10/04 23:02:54  mamont
Исправлена ошибка в выдаче диагностики
в предыдущей версии.

Добавлены дополнительные коды выхода
(см. xcode -H, раздел КОДЫ ВЫХОДА)

Добавлен переключатель --, по которому
прерывается разбор командной строки.

Добавлено сообщение об ошибке в аргументах
лпрограммы, ежели такая просходит.

Revision 3.3  2003/09/27 18:37:05  mamont
переформатировал комментарии

Revision 3.2  2003/09/27 18:35:43  mamont
Совсем забыл: теперь программа выходит
с ненулевым кодом при какой-либо ошибке.
Сами ошибки можно посмотреть в тексте:
E_OK и т.д.

Revision 3.1  2003/09/27 18:28:26  mamont
Теперь опции вида /h допустимы только при 
выходной кодировке D_ALT

По опции "--" сканирование аргументов 
останавливается. Следующие аргументы 
рассматриваются как имена файлов.

Revision 3.0  2003/04/03 20:00:35  mamont
Смена версии на 3.0
команда: ci -f3.0 xcode.c

Revision 2.10  2003/04/03 19:47:12  mamont
Поправлена ошибка в кодировке "mac", на которую
любезно указал Сергей Скотников (неверный код
буквы «я»). Используемая библиотека
перестановочной перекодировки с
http://www.rusf.ru/books/yo/encoding.html получила
название SRECODE.C и явно выделена в тексте
программы комментариями.

Revision 2.9  2003/03/31 15:46:49  mamont
Текст приведён к стандарту C99 (по модулю
предупреждений о конвертации между
знаковыми/беззнаковыми буквами). Бороться с этим
можно явным заданием преобразования указателей, но
не нужно в силу усложнения кода. 

Revision 2.8  2003/03/26 02:17:16  mamont
Поправлено предупреждение 
"suspicious pointer conversion"

Revision 2.7  2003/03/26 02:14:13  mamont
Добавлено декодирование html-Уникоденных текстов
(вроде &amp;#1044;&amp;#1080;&amp;#1084;&amp;#1072;)

Revision 2.6  2003/03/10 17:36:26  mamont

Информация о режиме silent добавленая в
справку


Revision 2.5  2003/03/10 17:30:05  mamont

Добавлен режим silent по опции -s

Revision 2.4  2003/03/09 01:42:47  mamont

Исправлено неправильное поведение при
одном имени файла

Revision 2.3  2003/03/08 19:57:28  mamont

Теперь программа компилируется bc 3.1
без предупреждений и ошибок.

Revision 2.2  2003/03/08 19:33:27  mamont

Режим трубы теперь по умолчанию только в
Досе/Виндах. (Дос/Win определяется по
переключателю D_ALT)

Revision 2.1  2003/03/08 19:25:05  mamont

*** empty log message ***

Revision 2.0  2003/03/08 19:23:31  mamont

Смена номера версии на 2.0

Revision 1.14  2003/03/08 19:13:24  mamont

Значительные улучшения по сравнению с
предыдущей версией. Теперь имеется опция
с трубой -p, а под Досовской консолью по
умолчанию программа выводит краткую
помощь.

Если входная кодировка уже указана, то
программа не определяет её
автоматически, а сразу производит
перекодировку. Единственный тонкий
момент: когда надо перекодировать файл
на месте. В этом случае используется
временный файл на диске, как и всегда.

Revision 1.13  2003/03/08 16:24:13  mamont

Добавил Revision

Revision 1.12  2003/03/08 16:17:35  mamont

Начат лог изменений

</PRE>
<P>
<H2><A name=tth_sEc7>7</A>&nbsp;&nbsp;Награды программы</H2>
<P>
<CENTER><A href="http://www.listsoft.ru/program.php?id=8777"><IMG height=60 alt=COOL! src="Перекодировщик xcode_files/cool.gif" width=80 border=0></A> COOL! от ListSoft <A href="http://www.listsoft.ru/program.php?id=8777"><TT>http://www.listsoft.ru/program.php?id=8777</TT></A> </CENTER>
<P>
<H2><A name=tth_sEc8>8</A>&nbsp;&nbsp;Лицензия Ё-ware</H2><A name=l:license></A>Программа xcode является Ё-ware. Именно, её можно свободно распространять, модифицировать, и даже дизассемблировать как в двоичном виде, так и в исходном тексте. Однако, используя эту программу, вы должны использовать букву Ё во всех текстах, которые набираете на компьютерах: начиная с электронных писем и заканчивая крупной прозаической формой. 
<P>
<H2><A name=tth_sEc9>9</A>&nbsp;&nbsp;Дополнительные вопросы</H2>По всем вопросам и пожеланиям, связанным с программой, обращайтесь по моему адресу, указанному в конце страницы. Желательно в поле Subject указать слово xcode. 
<P>
<P>
<H1>Содержание </H1><A href="#tth_sEc1">1&nbsp; Зачем нужен ещё один перекодировщик?</A><BR><A href="#tth_sEc2">2&nbsp; Установка и компиляция</A><BR><A href="#tth_sEc3">3&nbsp; Особенности использования</A><BR><A href="#tth_sEc4">4&nbsp; Применения</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.1">4.1&nbsp; Сортировка</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.2">4.2&nbsp; Внутренний перекодировщик</A><BR>&nbsp;&nbsp;&nbsp;&nbsp;<A href="#tth_sEc4.3">4.3&nbsp; Фильтр на входной почте</A><BR><A href="#tth_sEc5">5&nbsp; О перестановочной кодировке и iconv</A><BR><A href="#tth_sEc6">6&nbsp; Лог изменений программы</A><BR><A href="#tth_sEc7">7&nbsp; Награды программы</A><BR><A href="#tth_sEc8">8&nbsp; Лицензия Ё-ware</A><BR><A href="#tth_sEc9">9&nbsp; Дополнительные вопросы</A><BR>
<P>
<P>
<HR>

<H3>Примечания:</H3>
<P><A name=tthFtNtAAB></A><A href="#tthFrefAAB"><SUP>1</SUP></A>т.е. символы из расширения ASCII, не совпадающие с алфавитными, могут утеряться. Например, перекодированный исполнимый файл, скорее всего, теряется при использовании обычных перекодировщиков безвозвратно.</P></TD></TR></TBODY></TABLE></BODY></HTML>
<!DOCTYPE HTML>
<!-- saved from url=(0052)http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm -->

<html>
<head>
  <title>Справочное руководство по языку Lua 4.0</title>
  <meta content="Alexey V. Pautov" name="Author">
  <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
  <meta content="MSHTML 6.00.3790.0" name="GENERATOR">
<style type="text/css">
body,tr,td {font-family:verdana; font-size:0.9em;}
a {color:#000080; text-decoration:none;}
a:hover {color:red;}
h1 {font-size:1.3em}
h2 {font-size:1.2em}
h3 {font-size:1.2em}
</style>
</head>
<body>
  <h1>Язык LUA</h1>

  <h2>Справочное руководство по языку программирования Lua 4.0</h2>

  <h1>1 Введение</h1>

  <h1>1.1 Что такое Lua?</h1>

  <p>Сайт языка Lua: <a href="http://www.tecgraf.puc-rio.br/lua">http://www.tecgraf.puc-rio.br/lua</a>.</p>

  <p>Lua представляет собой ядро языка, которое Вы можете внедрять в Вашу прикладную программу. Это означает, что, помимо синтаксиса и семантики, Lua имеет API, который позволяет прикладной программе обмениваться данными с программами на Lua и расширять Lua функциями на C. В этом смысле, Lua может быть расценен как некий базисный метаязык для формирования проблемно-зависимых языков программирования.</p>

  <p>Lua был предоставлен первый приз (технологическая категория) в Second Compaq Award for Research and Development in Computer Science в 1997. Это вознаграждение было объединенным предприятием Compaq Computer Brazil, the Brazilian Ministry of Science and Technology и the Brazilian Academy of Sciences.</p>

  <p>Lua использовался во многих различных проектах во всем мире. Краткий перечень есть на http://www.tecgraf.puc-rio.br/lua/uses.html.</p>

  <p>Lua объединяет простой процедурный синтаксис (подобный Паскалю) с мощными конструкциями описания данных, основанными на ассоциативных массивах и расширяемой семантике. Lua имеет динамические типы, интерпретируется из байт-кода и имеет автоматическое управление памятью.</p>

  <p>Lua представляет собой мощный, легкий язык программирования расширений разработанный, чтобы поддерживать общее процедурное программирование для средств описания данных. Lua предназначен, чтобы использоваться как мощный и легкий язык конфигураций для любой программы, которая нуждается в этом, и для расширения прикладных программ. Lua также часто используется как автономный язык общего назначения.</p>

  <p>Цели реализации: простота, эффективность, мобильность и низкая объемлющая стоимость. Результат: быстрое ядро языка с маленькими требованиями, что делает его идеальным также и во встроенных системах.</p>

  <p>Lua написан как библиотека на C, написан на ANSI C и компилирует неизменяемый на всех известных платформах код. Будучи языком расширений, Lua не имеет никакого понятия главной программы: это работает только как вложение в некую <em>ведущую</em> программу. Эта ведущая программа может вызывать функции, чтобы выполнить часть кода в Lua, может писать и читать переменные Lua, и может регистрировать функции C, которые будут вызваны Lua-кодом. С помощью функций C, Lua может быть расширена, чтобы справиться с широким диапазоном различных областей, таким образом создавая настроенные языки программирования, совместно использующие синтаксические рамки.</p>

  <h1>1.2 Доступность</h1>

  <p>Lua свободно доступен для академических и коммерческих целей и может быть скачан с различных сайтов в сети:</p>
  <pre>
  Базовые  http://www.tecgraf.puc-rio.br/lua
  сайты:   http://csg.uwaterloo.ca/~lhf/lua

  Зеркала:
  Brazil:  ftp://ftp.tecgraf.puc-rio.br/pub/lua/
  Canada:  ftp://csg.uwaterloo.ca/pub/lhf/lua/
  USA:     ftp://ftp.freesoftware.com/pub/languages/lua/
  Germany: ftp://ftp.uni-trier.de/pub/languages/lua/
  Germany: ftp://ftp.gwdg.de/pub/languages/lua/
  Greece:  ftp://ftp.ntua.gr/pub/lang/lua/
  Japan:   ftp://ftp.u-aizu.ac.jp/pub/lang/lua/
  Denmark: ftp://ftp.ucore.com/lua/dist
</pre>

  <p>Lua распространяется свободно. Реализация, описанная в этом руководстве, доступна по адресам: <a href="http://www.tecgraf.puc-rio.br/lua">http://www.tecgraf.puc-rio.br/lua</a> и <a href="ftp://ftp.tecgraf.puc-rio.br/pub/lua">ftp://ftp.tecgraf.puc-rio.br/pub/lua</a>.</p>

  <h1>1.3 Связь с авторами</h1>

  <p>Lua был разработан и выполнен Waldemar Celes, Roberto Ierusalimschy и Luiz Henrique de Figueiredo. С ними можно входить в контакт по e-mail lua@tecgraf.puc-rio.br.</p>

  <p>Шлите Ваши комментарии, вопросы и отчеты об ошибках на lua@tecgraf.puc-rio.br. Для сообщений об ошибках попробуйте также список рассылки lua-l@tecgraf.puc-rio.br. Для получения большего количества информации относительно этого списка, включая инструкции о том, как на него подписаться, обратитесь на http://www.tecgraf.puc-rio.br/lua/lua-l.html.</p>

  <p>Lua разработан в TeCGraf, the Computer Graphics Technology Group of PUC-Rio (the Pontifical Catholic University of Rio de Janeiro in Brazil). TeCGraf является лабораторией отдела информатики. Множество индустриальных программ, разработанных в TeCGraf, используют Lua.</p>

  <h1>2 Среда и составные части</h1>

  <p>Все инструкции в Lua выполнены в глобальной среде. Эта среда будет инициализирована обращением к <code>lua_open</code> и сохранится до обращения к <code>lua_close</code> или до завершения ведущей программы. В случае необходимости программист может создавать много независимых глобальных сред и свободно переключаться между ними.</p>

  <p>Глобальная среда может управляться Lua-кодом или ведущей программой, которая может читать и писать глобальные переменные, используя функции API из библиотеки, которая предоставлена Lua.</p>

  <p>Глобальные переменные в Lua не должны быть объявлены. Любая переменная считается глобальной, пока не объявлена явно как локальная. Перед первым назначением, значение глобальной переменной <b>nil</b> (это значение по умолчанию может быть изменено, подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#tag-method">4.8</a>). Таблица используется, чтобы хранить все глобальные имена и значения (таблицы объясняются в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#TypesSec">3</a>).</p>

  <p>Модуль выполнения Lua назван составной частью. Это просто последовательность инструкций, которые выполнены последовательно. Каждая инструкция может факультативно сопровождаться точкой с запятой:</p>
  <pre>
chunk ::= {stat [`;&#39;]}
</pre>Инструкции описаны в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#stats">4.4</a>. Запись выше представляет собой обычный расширенный BNF, в котором {<em>a</em>} соответствует 0 или более объектов <em>a</em> [<em>a</em>] означает факультативный <em>a</em>, а (<em>a</em>)+ задает один или большее количество <em>a</em>. Полный синтаксис Lua дан в <a href="http://www.botik.ru/~rldp/mysql/mysqldev/BNF">BNF</a>.

  <p>Составная часть (chunk) может быть сохранена в файле или в строке в ведущей программе. Когда chunk выполняется, сначала проводится прекомпиляция в байт-код для реальной машины, а затем инструкции будут выполнены в последовательном порядке, моделируя действительную машину. Все модификации глобальной среды сохраняются после окончания работы кода.</p>

  <p>Chunk также может быть прекомпилирован в двоичную форму и сохранен в файле. Подробности есть в описании программы <a name="luac"></a><a href="http://www.botik.ru/~rldp/mysql/mysqldev/luac.htm">luac</a>. Текстовые файлы с кодом и их двоичные прекомпилированные формы взаимозаменяемы. Lua автоматически обнаруживает тип файла и действует соответственно.</p>

  <h1>3 Типы и тэги</h1>

  <p>Lua представляет собой <em>dynamically typed language</em>. Это означает, что переменные не имеют типов, а только значения. Следовательно, не имеется никаких определений типов на языке. Все значения несут их собственный тип. Помимо типа все значения также имеют <a name="tag"><em>тэг</em></a>.</p>

  <p>Имеются шесть <a name="basic types">базисных типов в Lua</a>: <a name="nil"><em>nil</em></a>, <a name="number"><em>number (число)</em></a>, <a name="string"><em>string (строка)</em></a>, <a name="function"><em>function (функция)</em></a>, <a name="userdata"><em>userdata (пользовательские данные)</em></a> и <a name="table"><em>table (таблица)</em></a>. <em>Nil</em> тип значения <b>nil</b>, чье основное свойство должно отличаться от любого другого значения. <em>Number</em> представляет реальные (двойная точность с плавающей запятой) числа, в то время как <em>string</em> имеет обычное значение. Lua нормально понимает 8-разрядные символы, так что строки могут содержать любой 8-разрядный символ, включая вложенные нули (<code>&#39;\0&#39;</code>). Подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#lexical">4.1</a>. Функция <code>type</code> возвращает строку, описывающую тип данного значения (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#pdf-type">6.1</a>).</p>

  <p>Функции рассматриваются как значения первого класса (<em>first-class values</em>) в Lua. Это означает, что функции могут быть сохранены в переменных, переданы как параметры другим функциям и возвращены как результаты. Lua может вызывать и управлять как функциями, написанными на Lua, так и функциями, написанными на C. Два вида функций могут различаться их тэгами: все функции Lua имеют тот же самый тэг, и все функции C имеют свой тэг, который отличается от тэга функций Lua. Функция <code>tag</code> возвращает тэг данного значения (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#pdf-tag">6.1</a>).</p>

  <p>Тип <em>userdata</em> обеспечивается, чтобы позволить произвольным C-указателям быть сохраненными в Lua-переменных. Этот тип соответствует <code>void*</code> и не имеет никаких предопределенных операций в Lua, за исключением теста равенства и назначения. Однако, используя <em>методы тэгов</em>, программист может определять операции для значений <em>userdata</em>. Подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#tag-method">4.8</a>.</p>

  <p>Тип <em>table</em> осуществляет ассоциативные массивы, то есть массивы, которые могут быть индексированы не только числами, а любыми значениями (за исключением <b>nil</b>). Следовательно, этот тип может использоваться не только, чтобы представить обычные массивы, но также и символные таблицы, наборы, записи, графы, деревья и т.д. Таблицы представляют собой основной механизм, структурирующий данные в Lua. Чтобы представлять записи (<a name="records">records</a>), Lua использует имя поля как индекс. Язык поддерживает это представление, обеспечивая <code>a.name</code> как синтаксический аналог для <code>a[&quot;name&quot;]</code>. Таблицы могут также нести <em>методы</em>: поскольку функции представляют собой значения первого класса, поля таблицы могут содержать функции. Форма <code>t:f(x)</code> синтаксический аналог для <code>t.f(t,x)</code>, который вызывает метод <code>f</code> из таблицы <code>t</code> прохождением таблицы непосредственно как первый параметр (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#func-def">4.5.9</a>).</p>

  <p>Обратите внимание, что таблицы представляют собой <em>объекты</em>, а не значения. Переменные не содержат таблицы, только ссылаются на них. Назначение, обработка параметра и возврат всегда управляют ссылками на таблицы и не подразумевают никакого вида копирования. Кроме того, таблицы должны быть явно созданы прежде, чем используются. Подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#tableconstructor">4.5.7</a>.</p>

  <p>Каждый из типов <em>nil</em>, <em>number</em> и <em>string</em> имеет свой тэг. Вообще, очень многое в Lua построено именно вокруг тэгов. Все значения каждого из этих типов имеют тот же самый предопределенный тэг. Как объяснено выше, значения типа <em>function</em> могут иметь два различных тэга в зависимости от того, являются ли они функциями Lua или функциями C. В заключение, значения типов <em>userdata</em> и <em>table</em> могут иметь переменные тэги, назначенные программистом (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#tag-method">4.8</a>). Функция <code>tag</code> возвращает тэг данного значения. Пользовательские тэги могут быть созданы функцией <code>newtag</code>. Функция <code>settag</code> используется, чтобы изменить тэг таблицы (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#pdf-newtag">6.1</a>). Тэг значений userdata может быть установлен из C (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#C-tags">5.7</a>). Тэги главным образом используются, чтобы выбрать соответствующие <em>методы тэгов</em>, когда происходят некоторые события. Методы тэгов представляют собой основной механизм для распространения семантики Lua (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#tag-method">4.8</a>). </p>

  <h1>4 Язык</h1>

  <p>Этот раздел описывает лексику, синтаксис и семантику Lua.</p>

  <p><a name="lexical"></a></p>

  <h2>4.1 Лексические соглашения в языке</h2>

  <p><a name="Identifiers"><em>Идентификатором</em></a> в Lua может быть любая строка символов, цифр и символов подчеркивания, не начинающаяся цифрой. Это совпадает с определением идентификаторов в большинстве языков, за исключением того, что определение символа зависит от текущего региона. Любой символ, который считается алфавитным в текущем языке, может использоваться в идентификаторе. То есть, алфавитные символы берутся из настроек текущей системной локали. Замечу, что для лучшей переносимости программ и их применения в разных регионах лучше все же ограничиться латинским алфавитом, цифрами и символом подчеркивания: они применимы везде. Следующие слова <em>зарезервированы</em>, и не могут использоваться как идентификаторы: <a name="reserved words"></a></p>
  <pre>
and       break     do        else      elseif    return
end       for       function  if        in        then
local     nil       not       or repeat until   while
</pre>

  <p>Lua представляет собой язык, чувствительный к регистру символов: <tt>and</tt> является зарезервированным словом, но <tt>And</tt> и <tt>AND</tt> (если региональный язык разрешает) не одно и то же. Значит, приведенные варианты уже можно использовать как имена переменных. Кроме того, идентификаторы, начинающиеся с символа подчеркивания, сопровождаемого прописными буквами (типа <code>_INPUT</code>) зарезервированы для внутренних переменных. Их не стоит применять в своих программах.</p>

  <p>Следующие строки обозначают другие лексемы (<a name="tokens">tokens</a>):</p>
  <pre>
~=    &lt;=    &gt;=    &lt;     &gt;     ==    =     +     -     *
(     )     {     }     [     ]     ;     ,     .     ..    ...   /
</pre>

  <p><a name="Literal strings"><em>Литеральные строки</em></a> могут быть разграничены одиночными или двойными кавычками, и могут содержать C-подобные управляющие последовательности: <code>\a</code> (bell), <code>\b</code> (backspace), <code>\f</code> (form feed), <code>\n</code> (newline), <code>\r</code> (carriage return), <code>\t</code> (horizontal tab), <code>\v</code> (vertical tab), <code>\\</code> (backslash), <code>\&quot;</code> (double quote), <code>\&#39;</code> (single quote), и <code>\</code><em>newline</em> (то есть, наклонная черта влево, сопровождаемая реальным newline, который приводит к переводу строки). Символ в строке может также быть определен числовым значением, через управляющую последовательность <code>\</code><em>ddd</em>, где <em>ddd</em> последовательность до трех <em>десятичных</em> цифр. Строки в Lua могут содержать любое 8-разрядное значение, включая вложенные нули, которые могут быть определены как <code>\000</code>.</p>

  <p>Литеральные строки могут также быть разграничены парами <code>[[</code> ... <code>]]</code>. Литералы в этой форме в скобках могут занимать по несколько строк, содержать вложенные пары скобок <code>[[</code> ... <code>]]</code> и не интерпретировать управляющие последовательности. Эта форма особенно удобна для записи строк, которые содержат части программы или другие цитируемые строки. Как пример, в системе использующей ASCII-кодировку, следующие три литерала эквивалентны:</p>
  <pre>
1)   &quot;alo\n123\&quot;&quot;
2)   &#39;\97lo\10\04923&quot;&#39;
3)   [[alo
     123&quot;]]
</pre>

  <p><a name="Comments"><em>Комментарии</em></a> начинаются с двойного тире (<code>--</code>) и выполняются до конца строки. Кроме того, первая строка составной части всегда пропущена, если начинается с символа <code>#</code>. Это средство позволяет использование Lua как интерпретатора скриптов в Unix-системах.</p>

  <p><a name="Numerical constants"><em>Числовые константы</em></a> могут быть написаны с факультативной целой частью и тоже факультативным дробной частями. Допустимо применение экспоненциальной формы запитси. Примеры имеющих силу числовых констант:</p>
  <pre>
3     3.0     3.1416  314.16e-2   0.31416E1
</pre>

  <p><a name="coercion"></a></p>

  <h2>4.2 Приведение</h2>

  <p>Lua обеспечивает некоторые автоматические преобразования между значениями во время выполнения. Любая арифметическая операция, примененная к строке, пробует преобразовывать эту строку в соответствующее число, следуя обычным правилам. Наоборот, всякий раз, когда используется число, а ожидается строка, это число будет преобразовано в строку в приемлемом формате. Формат выбран так, чтобы преобразование из числа в строку было таким, чтобы обратное преобразование из строки в число было <em>точным</em>. Таким образом, преобразование не обязательно генерирует хороший текст для некоторых чисел. Для полного управления тем, как числа будут преобразованы в строки, используйте функцию <code>format</code> (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#format">6.2</a>). <a name="adjust"></a></p>

  <h2>4.3 Корректировка</h2>

  <p>Функции в Lua могут возвращать много значений. Потому, что не имеется никаких объявлений типа когда функция вызвана, система не знает, сколько значений вернется, или сколько параметры требуется. Следовательно, иногда список значений должен быть откорректирован во время выполнения к данной длине. Если имеется большее количество значений, чем необходимы, то лишние значения отбрасываются. Если имеется меньшее количество значений, чем необходимы, то список расширен добавлением потребного количества <b>nil</b>. Эта корректировка происходит в многократных назначениях (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#assignment">4.4.2</a>) и в обращениях к функции (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#functioncall">4.5.8</a>). <a name="stats"></a></p>

  <h2>4.4 Инструкции</h2>

  <p>Lua поддерживает почти стандартный набор инструкций, подобных таким же наборам на Pascal или C. Стандартные команды включают присваивание, контроль выполнения и вызовы процедур. Нестандартные команды включают конструкторы таблицы и объявления локальных переменных.</p>

  <h3>4.4.1 Блоки</h3><a name="block">Блоком</a> является список инструкций. Синтаксически блок равен составной части (chunk):
  <pre>
block ::= chunk
</pre>

  <p>Блок может быть явно разграничен:</p>
  <pre>
stat ::= <b>do</b> block <b>end</b>
</pre>Явные блоки полезны, чтобы управлять областью видимости (контекстом) локальных переменных. Явные блоки также иногда используются, чтобы добавить возврат или разрывать инструкцию в середине другого блока.

  <p><a name="assignment"></a></p>

  <h3>4.4.2 <a name="Assignment">Присваивания</a></h3>Lua поддерживает такую удобную вещь, как <a name="multiple assignment">многократные присваивания</a>. Следовательно, синтаксис определяет список переменных с левой стороны и список выражений с правой сторона. Элементы в обоих списках отделяются запятыми:
  <pre>
stat ::= varlist1 `<b>=</b>&#39; explist1
varlist1 ::= var {`<b>,</b>&#39; var}
</pre>Эта инструкция сначала оценивает все значения справа и возможные индексы слева, а затем делает примваивание. Так, код:
  <pre>
i = 3
i, a[i] = 4, 20
</pre>установит <code>a[3]</code> в 20, но не воздействует на <code>a[4]</code> потому, что <code>i</code> в <code>a[i]</code> оценен прежде, чем ему было присвоено значение <code>4</code>. Многократное присваивание может использоваться, чтобы поменять местами два значения, например:
  <pre>
x, y = y, x
</pre>

  <p>Два списка в многократном присваивании могут иметь различные длины. Перед собственно присваиванием, список значений будет откорректирован к длине списка имеющихся переменных.</p>

  <p>Одиночное имя может обозначать глобальную переменную, локальную переменную или формальный параметр:</p>
  <pre>
var ::= name
</pre>

  <p>Квадратные скобки используются, чтобы индексировать таблицу:</p>
  <pre>
var ::= varorfunc `<b>[</b>&#39; exp1 `<b>]</b>&#39;
varorfunc ::= var | functioncall
</pre><em>varorfunc</em> должен иметь в качестве результата значение из таблицы, где поле, индексированное значением выражения <em>exp1</em>, получает назначенное ему значение.

  <p>Синтаксис <code>var.NAME</code> представляет собой только синтаксический аналог для выражения <code>var[&quot;NAME&quot;]</code>:</p>
  <pre>
var ::= varorfunc `.&#39; name
</pre>

  <p>Значение присваиваний, оценок глобальных переменных и индексированных переменных может быть изменено методами тэгов. Фактически, назначение <code>x=val</code>, где <code>x</code> представляет собой глобальную переменную, является эквивалентным обращению <code>setglobal(&quot;x&quot;,val)</code>, а присваивание <code>t[i]=val</code> эквивалентно <code>settable_event(t,i,val)</code>. В разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#tag-method">4.8</a> есть полное описание этих функций (<code>setglobal</code> находится в базисной библиотеке, <tt>settable_event</tt> используется только для объяснительных целей). <a name="control"></a></p>

  <h3>4.4.3 Структуры управления</h3>Структуры управления <b>if</b>, <b>while</b> и <b>repeat</b> имеют обычное значение и знакомый синтаксис: <a name="while-do statement"></a><a name="repeat-until statement"></a><a name="if-then-else statement"></a>
  <pre>
stat ::= while exp1 do block end
stat ::= repeat block until exp1
stat ::= if exp1 then block {elseif exp1 then block} [else block] end
</pre><a name="condition expression">Выражение</a> <em>exp1</em> условия структуры управления может возвращать любое значение. Все значения, отличные от <b>nil</b>, рассматриваются как истина, только <b>nil</b> считается ложью.

  <p>Инструкция <b>return</b> используется, чтобы возвратить значения из функции или из chunk. <a name="return"></a><a name="return statement"></a>Поскольку функции или составные части могут возвращать больше, чем одно значение, синтаксис для инструкции <b>return</b>:</p>
  <pre>
stat ::= <b>return</b> [explist1]
</pre>

  <p>Инструкция <b>break</b> может использоваться, чтобы завершить выполнение цикла, переходя к следующей инструкции сразу после цикла: <a name="break statement"></a></p>
  <pre>
stat ::= <b>break</b>
</pre><b>break</b> заканчивает самый внутренний вложенный цикл (<b>while</b>, <b>repeat</b> или <b>for</b>).

  <p>По синтаксическим причинам инструкции <b>return</b> и <b>break</b> могут быть написаны только как <em>последние инструкции блока</em>. Если действительно необходимо вставить их в середину, надо применить явный внутренний блок, например, <code>do return end</code> потому, что теперь <b>return</b> в самом деле последняя инструкция во внутреннем блоке. <a name="for"></a></p>

  <h3>4.4.4 Инструкция For</h3><a name="for statement"></a>

  <p>Инструкция <b>for</b> имеет две формы, по одной для чисел и таблиц. Числовая версия цикла <b>for</b> имеет следующий синтаксис:</p>
  <pre>
stat ::= for name `=&#39; exp1 `,&#39; exp1 [`,&#39; exp1] do block end
</pre>Инструкция <b>for</b>, подобная:
  <pre>
for var = e1 ,e2, e3 do block end
</pre>является заменителем кода:
  <pre>
do
  local var, _limit, _step = tonumber(e1), tonumber(e2), tonumber(e3)
  if not (var and _limit and _step) then error() end
  while (_step&gt;0 and var&lt;=_limit) or
        (_step&lt;=0 and var&gt;=_limit) do
    block
    var = var+_step
  end
end
</pre>Обратите внимание на следующее:

  <ul>
    <li>sep=0pt</li>

    <li><code>_limit</code> и <code>_step</code> являются невидимыми переменными. Имена здесь даны только для объяснительных целей.</li>

    <li>Поведение <em>неопределено</em>, если Вы меняете значение <code>var</code> внутри блока.</li>

    <li>Если третье выражение (step) отсутствует, то используется step 1.</li>

    <li>Значения limit и step оценены только однажды, перед стартом цикла.</li>

    <li>Переменная <code>var</code> локальна для инструкции: Вы не можете использовать ее значение после окончания работы <b>for</b>.</li>

    <li>Вы можете использовать <b>break</b>, чтобы выйти из <b>for</b>. Если Вы нуждаетесь в значении индекса, присвойте его другой переменной перед выходом.</li>
  </ul>

  <p>Таблица для инструкции <b>for</b> пересекает все пары (index,value) данной таблицы. Это имеет следующий синтаксис:</p>
  <pre>
stat ::= for name `,&#39; name in exp1 do block end
</pre>Инструкция <b>for</b>, подобная:
  <pre>
for index, value in exp do block end
</pre>равносильна такому коду:
  <pre>
do
  local _t = exp
  local index, value = next(t, nil)
  while index do
    block
    index, value = next(t, index)
  end
end
</pre>Обратите внимание на следующее:

  <ul>
    <li>sep=0pt</li>

    <li><code>_t</code> является невидимомй переменномй. Имя здесь дано только для объяснительных целей.</li>

    <li>Поведение <em>неопределено</em>, если Вы меняете значение <code>index</code> внутри блока.</li>

    <li>Поведение <em>неопределено</em>, если Вы меняете таблицу <code>_t</code> при работе цикла.</li>

    <li>Переменнае <code>index</code> и <code>var</code> локальны для инструкции: Вы не можете использовать их значения после окончания работы <b>for</b>.</li>

    <li>Вы можете использовать <b>break</b>, чтобы выйти из <b>for</b>. Если Вы нуждаетесь в значениях <code>index</code> или <code>value</code>, присвойте их другим переменным перед выходом.</li>

    <li>Порядок, в котором элементы таблицы будут пересечены, неопределен, <em>даже для числовых индексов</em>. Если Вы хотите пересекать индексы в числовом порядке, используйте числовой вариант <b>for</b>.</li>
  </ul><a name="funcstat"></a>

  <h3>4.4.5 Обращения к функции как инструкции</h3>Из-за возможных побочных эффектов, обращения к функции могут быть выполнены как инструкции:
  <pre>
stat ::= functioncall
</pre>В этом случае все возвращенные значения утрачены. Обращения к функции объясняются в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#functioncall">4.5.8</a>. <a name="localvar"></a>

  <h3>4.4.6 Локальные объявления</h3><a name="Local variables">Локальные переменные</a> могут быть объявлены где-нибудь внутри блока. Объявление может включать начальное присваивание:
  <pre>
stat ::= <b>local</b> declist [init]
declist ::= name {`<b>,</b>&#39; name}
init ::= `<b>=</b>&#39; explist1
</pre>Если представлено начальное назначение, то оно имеет ту же самую семантику многократного назначения. Иначе все переменные инициализированы <b>nil</b>.

  <p>Сhunk также блок, так что локальные переменные могут быть объявлены снаружи любого явного блока.</p>

  <p>Область действия (контекст) локальных переменных начинается после объявления и продолжается до конца блока. Таким образом, код <code>local print=print</code> создает локальную переменную, названную <code>print</code>, чье начальное значение будет взято из <em>глобальной</em> переменной с тем же самым именем. </p>

  <h2>4.5 Выражения</h2>

  <h3>4.5.1 <a name="Basic Expressions">Базисные выражения</a></h3>

  <p>Базисные выражения в Lua такие:</p>
  <pre>
exp ::= `(&#39; exp `)&#39;
exp ::= nil
exp ::= number
exp ::= literal
exp ::= var
exp ::= upvalue
exp ::= function
exp ::= functioncall
exp ::= tableconstructor
</pre>

  <p>Доступ к глобальной переменной <code>x</code> эквивалентен обращению <code>getglobal(&quot;x&quot;)</code>, а доступ к индексированной переменной <code>t[i]</code> эквивалентен обращению к <code>gettable_event(t,i)</code>. Подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#tag-method">4.8</a>, там есть описания этих функций (<code>getglobal</code> находится в базисной библиотеке).</p>

  <p>Нетерминальный <em>exp1</em> используется, чтобы указать, что значения, возвращенные выражением должны быть откорректированы к одному значению:</p>
  <pre>
exp1 ::= exp
</pre>

  <h3>4.5.2 Арифметические операторы</h3>Lua поддерживает комплект обычных арифметических операторов: двоичный <code>+</code> (сложение), <code>-</code> (вычитание), <code>*</code> (умножение), <code>/</code> (деление), <code>^</code> (возведение в степень), а также унарный <code>-</code> (обращение знака числа). Если операнды числа или строки, которые могут быть преобразованы в числа, (согласно правилам, данным в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#coercion">4.2</a>), то все операции за исключением возведения в степень имеют обычное значение. Иначе будет вызван соответствующий метод тэга. Возведение в степень всегда вызывает метод тэга. Стандартная математическая библиотека переопределяет этот метод для чисел, давая ожидаемое значение (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#mathlib">6.3</a>).

  <h3>4.5.3 Реляционные операторы</h3><a name="relational operators">Реляционные операторы</a> в Lua:
  <pre>
==    ~=    &lt;     &gt;     &lt;=    &gt;=
</pre>Эти операторы возвращают <b>nil</b> как ложь, или любое другое значение (но не <b>nil</b>) в качестве истины.

  <p>Равенство (<code>==</code>) сначала сравнивает тэги операндов. Если они различны, то результатом будет <b>nil</b>. Иначе сравниваются их значения. Числа и строки сравниваются обычным способом. Таблицы, userdata, и функции сравниваются как ссылки, то есть две таблицы рассматриваются равными только, если они реально та же самая таблица. Оператор <code>~=</code> прямо противоположен оператору равенства (<code>==</code>).</p>

  <p>Правила преобразования из раздела <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#coercion">4.2</a> <em>НЕ</em> применяются к сравнениям равенства. Таким образом, <code>&quot;0&quot;==0</code> вернет <em>false</em>, а <code>t[0]</code> и <code>t[&quot;0&quot;]</code> обозначают различные записи в таблице.</p>

  <p>Операторы порядка работают следующим образом. Если оба параметра числа, то они сравниваются также. Иначе, если оба параметра строки, то их значения сравниваются, используя лексикографический порядок. Во всех остальных ситуациях будет вызван метод lt тэга (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#tag-method">4.8</a>).</p>

  <h3>4.5.4 Логические операторы</h3><a name="logical operators">Логические операторы</a> в Lua: <a name="and"></a><a name="or"></a><a name="not"></a>
  <pre>
and   or   not
</pre>Подобно структурам управления, все логические операторы рассматривают <b>nil</b> как false (ложь), а все остальное как истину (true).

  <p>Оператор конъюнкции <code>and</code> вернет <b>nil</b>, если первый параметр <b>nil</b>, иначе это возвращает второй параметр. Оператор дизъюнкции <code>or</code> вернет первый параметр, если он отличается от <b>nil</b>, в противном случае это возвращает второй параметр. Операторы <code>and</code> и <code>or</code> используют <a name="short-cut evaluation">краткое вычисление</a>, то есть второй операнд оценен только в случае необходимости. Имеются две полезных идиомы в Lua, которые используют логические операторы. Первая идиома:</p>
  <pre>
x = x or v
</pre>Которая является эквивалентной:
  <pre>
if x == nil then x = v end
</pre>Эта идиома устанавливает <code>x</code> к значению по умолчанию <code>v</code>, когда <code>x</code> не установлен.

  <p>Вторая идиома такая:</p>
  <pre>
x = a and b or c
</pre>Которая должна читаться как <code>x=(a and b) or c</code>. Эта идиома эквивалентна:
  <pre>
if a then x = b else x = c end
</pre>При условии, что <code>b</code> не <b>nil</b>. <a name="concat"></a>

  <h3>4.5.5 Объединения</h3>Оператор <a name="concatenation">объединения</a> строк в Lua обозначен двумя точками (`<a name=".."><tt>..</tt></a>&#39;). Если оба операнда строки или числа, они будут преобразованы в строки согласно правилам в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#coercion">2</a>. Иначе будет вызван метод concat тэга.

  <h3>4.5.6 Старшинство</h3>Порядок <a name="Operator precedence">старшинства</a> в Lua следует из таблицы ниже. Операторы в ней перечислены в порядке от низкого к более высокому приоритету:
  <pre>
and   or
&lt;     &gt;     &lt;=    &gt;=    ~=    ==
..
+     -
*     /
not   - (unary)
^
</pre>Все двоичные операторы ассоциативны слева, кроме возведения в степень, который является ассоциативным справа. Прекомпилятор может перестраивать порядок оценки ассоциативных операторов (типа <code>..</code> или <code>+</code>), пока эти оптимизация не изменяют нормальные результаты. Однако, эти оптимизация могут изменять некоторые результаты, если Вы определяете не ассоциативные методы тэгов для этих операторов. <a name="tableconstructor"></a>

  <h3>4.5.7 Конструкторы таблиц</h3><a name="constructors">Конструкторы</a> таблиц представляют собой выражения, которые создают таблицы: каждый раз конструктор оценен, и новая таблица создана. Конструкторы могут использоваться, чтобы создать пустые таблицы или создать таблицу и инициализировать некоторые из полей (необязательно все). Общий синтаксис для конструкторов:
  <pre>
tableconstructor ::= `{&#39; fieldlist `}&#39;
fieldlist ::= lfieldlist|ffieldlist|lfieldlist `;&#39;
              ffieldlist|ffieldlist `;&#39; lfieldlist
lfieldlist ::= [lfieldlist1]
ffieldlist ::= [ffieldlist1]
</pre>

  <p>Форма <em>lfieldlist1</em> используется, чтобы инициализировать списки:</p>
  <pre>
lfieldlist1 ::= exp {`<b>,</b>&#39; exp} [`<b>,</b>&#39;]
</pre>Выражения в списке назначены последовательным числовым индексам, начиная с 1 (но не с 0!). Например, код:
  <pre>
a = {&quot;v1&quot;, &quot;v2&quot;, 34}
</pre>является эквивалентным коду:
  <pre>
do
  local temp = {}
  temp[1] = &quot;v1&quot;
  temp[2] = &quot;v2&quot;
  temp[3] = 34
  a = temp
end
</pre>

  <p>Форма <em>ffieldlist1</em> инициализирует другие поля в таблице:</p>
  <pre>
ffieldlist1 ::= ffield {`,&#39; ffield} [`,&#39;]
ffield ::= `[&#39; exp `]&#39; `=&#39; exp | name `=&#39; exp
</pre>Например такая запись:
  <pre>
a = {[f(k)] = g(y), x = 1, y = 3, [0] = b+c}
</pre>эквивалентна такому коду:
  <pre>
do
  local temp = {}
  temp[f(k)] = g(y)
  temp.x = 1    -- or temp[&quot;x&quot;] = 1
  temp.y = 3    -- or temp[&quot;y&quot;] = 3
  temp[0] = b+c
  a = temp
end
</pre>Выражения, подобные <code>{x=1, y=4}</code> фактически синтаксический аналог для выражения вида <code>{[&quot;x&quot;]=1, [&quot;y&quot;]=4}</code>.

  <p>Обе формы могут иметь факультативную конечную запятую и могут использоваться в том же самом конструкторе, разделенные точкой с запятой. Например, все формы ниже правильны:</p>
  <pre>
x = {;}
x = {&quot;a&quot;, &quot;b&quot;,}
x = {type=&quot;list&quot;; &quot;a&quot;, &quot;b&quot;}
x = {f(0), f(1), f(2),; n=3,}
</pre><a name="functioncall"></a>

  <h3>4.5.8 Вызовы функций</h3><a name="function call">Вызовы функций</a> в Lua имеют синтаксис:
  <pre>
functioncall ::= varorfunc args
</pre>Сначала вычисляется <em>varorfunc</em>. Если значение имеет тип <em>function</em>, то эта функция будет вызвана с данными параметрами. Иначе вызывается метод function тэга, имея первым параметром значение <em>varorfunc</em> с перечисленными затем первоначальными параметрами обращения. Подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#tag-method">4.8</a>.

  <p>Форма</p>
  <pre>
functioncall ::= varorfunc `:&#39; name args
</pre>Может использоваться, чтобы вызвать methods. Обращение <code>v:name(...)</code> синтаксически аналогично <code>v.name(v, ...)</code>, за исключением того, что <code>v</code> будет оценен только однажды. Параметры имеют следующий синтаксис:
  <pre>
args ::= `(&#39; [explist1] `)&#39;
args ::= tableconstructor
args ::= literal
explist1 ::= {exp1 `,&#39;} exp
</pre>Все выражения параметра оценены перед обращением. Обращение в форме <code>f{...}</code> синтаксически аналогично <code>f({...})</code>, то есть список параметров представляет собой одиночную новую таблицу. Обращение в форме <code>f&#39;...&#39;</code> (<code>f&quot;...&quot;</code> или <code>f[[...]]</code>) синтаксически аналогично <code>f(&#39;...&#39;)</code>, то есть список параметров представляет собой одиночную строку литералов.

  <p>Потому, что функция может возвращать любое число результатов, число результатов должно быть откорректировано прежде, чем они используются. Если функция вызвана как инструкция, то список возврата откорректирован к 0, таким образом отбрасывая все возвращенные значения. Если функция вызвана в месте, которое нуждается в одиночном значении (синтаксически обозначенном нетерминальным <em>exp1</em>), то список возврата откорректирован к 1, таким образом отбрасывая все возвращенные значения, но не первый. Если функция вызвана в месте, которое может использовать много значений (синтаксически обозначено нетерминальным <em>exp</em>), то никакая корректировка не будет сделана. Единственные места, которые могут обрабатывать много значений, это последние (или единственные) выражения в присваивании, в списке параметров или в инструкции <b>return</b>. Имеются примеры:</p>
  <pre>
f()                -- 0 результатов
g(f(), x)          -- f() 1 результат
g(x, f())          -- g получает x и все значения, возвращенные f()
a,b,c = f(), x     -- f() скорректирован к 1 результату (и c получает nil)
a,b,c = x, f()     -- f() 2 результата
a,b,c = f()        -- f() 3 результата
return f()         -- возвращает все значения, возвращенные f()
return x,y,f()     -- вернет a, b и все, что вернет f()
</pre><a name="func-def"></a>

  <h3>4.5.9 <a name="Function Definitions">Определение функций</a></h3>

  <p>Синтаксис для определения функций такой:</p>
  <pre>
function ::= function `(&#39; [parlist1] `)&#39; block end
stat ::= function funcname `(&#39; [parlist1] `)&#39; block end
funcname ::= name | name `.&#39; name | name `:&#39; name
</pre>Инструкция
  <pre>
function f () ... end
</pre>является только синтаксическим аналогом для
  <pre>
f = function () ... end
</pre>а инструкция
  <pre>
function v.f () ... end
</pre>является синтаксическим аналогом для
  <pre>
v.f = function () ... end
</pre>

  <p>Функциональное определение представляет собой выполнимое выражение, чье значение имеет тип <em>function</em>. Когда Lua прекомпилирует chunk, все функциональные тела также прекомпилируются. Затем, всякий раз, когда Lua выполняет функциональное определение верхние переменные (upvalues) фиксируются, и функция выполняется. Этот функциональный образец (или <em>замкнутое выражение</em>) представляет собой конечное значение выражения. Различные образцы той же самой функции могут иметь различные верхние переменные.</p>

  <p>Параметры действуют как локальные переменные, инициализированные со значениями параметра:</p>
  <pre>
parlist1 ::= `...&#39;
parlist1 ::= name {`,&#39; name} [`,&#39; `...&#39;]
</pre><a name="vararg"></a>Когда функция вызвана, список параметров будет откорректирован к длине списка параметров, если функция не <a name="vararg function"><em>vararg-функция</em></a>, которая обозначена тремя точками (`<code>...</code>&#39;) в конце списка параметра. Функция vararg не корректирует список параметров, вместо этого она собирает все лишние параметры в неявный параметр, названный <a name="arg"><tt>arg</tt></a>. Значением <code>arg</code> является таблицы из <code>n</code> полей, чьим значением является число параметров дополнительного пространства и сами эти параметры, перечисленные в полях 1, 2, ..., <code>n</code>.

  <p>Как пример, рассмотрите следующие определения:</p>
  <pre>
function f(a, b) end
function g(a, b, ...) end
function r() return 1,2,3 end
</pre>Имеем следующее отображение параметров:
  <pre>
ВЫЗОВ            ПАРАМЕТРЫ

f(3)             a=3, b=nil
f(3, 4)          a=3, b=4
f(3, 4, 5)       a=3, b=4
f(r(), 10)       a=1, b=10
f(r())           a=1, b=2
g(3)             a=3, b=nil, arg={n=0}
g(3, 4)          a=3, b=4, arg={n=0}
g(3, 4, 5, 8)    a=3, b=4, arg={5, 8; n=2}
g(5, r())        a=5, b=1, arg={2, 3; n=2}
</pre>

  <p>Результаты возвращены, используя инструкцию <b>return</b>. Если управление достигает конца функции без того, чтобы столкнуться с инструкцией <b>return</b>, то функция будет завершена без результатов.</p>

  <p>Синтаксис</p>
  <pre>
funcname ::= name `:&#39; name
</pre><a name="methods"></a>используется для определения <em>методов</em>, то есть функции, которые имеют неявный дополнительный параметр <tt>self</tt> <a name="self"></a>.

  <p>Инструкция</p>
  <pre>
function v:f (...) ... end
</pre>является только синтаксическим аналогом для
  <pre>
v.f = function (self, ...) ... end
</pre>Обратите внимание, что функция получает дополнительный формальный параметр <code>self</code>. <a name="upvalue"></a>

  <h2>4.6 Зона видимости и Upvalues</h2><a name="visibility"></a><a name="upvalues"></a>

  <p>Функциональное тело может обратиться к собственным локальным переменным (которые включают и параметры), а также к глобальным переменным, пока они не затенены локальными переменными с тем же самым именем. Функция <em>не может</em> обращаться к локальной переменной из функции включения, так как такие переменные больше не могут существовать, когда функция вызвана. Однако, функция может обращаться к значению локальной переменной из функции включения, используя upvalues, чей синтаксис:</p>
  <pre>
upvalue ::= `%&#39; name
</pre>

  <p>upvalue подобен переменному выражению, но его значение закрепляется, когда функция, в которой он появляется запускается. Имя, используемое в upvalue, может быть именем любой переменной, видимой в том месте, где функция определена, то есть пригодны глобальные переменные и локальные переменные. Обратите внимание, что, когда upvalue таблица, только <em>ссылка</em> на эту таблицу (которая и является значением upvalue) закрепляется, а содержание самой таблицы может быть изменено по желанию. Использование значений таблицы как upvalues представляет собой методику для наличия перезаписываемого но частного состояния, приложенного к функциям.</p>

  <p>Имеются некоторые примеры:</p>
  <pre>
a,b,c = 1,2,3   -- глобальные переменные
local d
function f (x)
  local b = {}  -- x и b локальны для f, b затеняет глобальную b
  local g = function (a)
    local y     -- a и y локальны для g
    p = a       -- OK, доступ к локальной a
    p = c       -- OK, доступ к глобальной c
    p = b       -- ERROR: невозможен доступ к переменной вне зоны видимости
    p = %b      -- OK, доступ к замороженной b (локальная f)
    %b = 3      -- ERROR: нельзя менять upvalue
    %b.x = 3    -- OK, изменение содержимого таблицы
    p = %c      -- OK, доступ к замороженному значению глобальной c
    p = %y      -- ERROR: `y&#39; невидима, где `g&#39; определена
    p = %d      -- ERROR: `d&#39; невидима, где `g&#39; определена
  end           -- g
end             -- f
</pre><a name="errors"></a>

  <h2>4.7 Обработка ошибок</h2>

  <p>Поскольку Lua язык расширений, все действия Lua начинаются из C-кода в ведущей программе, вызывающей функцию из Lua-библиотеки. Всякий раз, когда ошибка происходит в течение Lua-трансляции или выполнения, вызывается функция <code>_ERRORMESSAGE</code> <a name="_ERRORMESSAGE"></a>и затем соответствующая функция из библиотеки (<code>lua_dofile</code>, <code>lua_dostring</code>, <code>lua_dobuffer</code> или <code>lua_call</code>) завершена, возвращая условие ошибки.</p>

  <p>Ошибки распределения памяти представляют собой исключительную ситуацию из предыдущего правила. Когда происходит сбой распределения памяти, Lua не может выполнить функцию <code>_ERRORMESSAGE</code>. Так что, для этого вида ошибки, Lua не вызывает функцию <code>_ERRORMESSAGE</code>. Вместо этого соответствующая функция из библиотеки немедленно завершится со специальным кодом ошибки (<code>LUA_ERRMEM</code>). Это и другие коды ошибки определено в заголовочном файле <code>lua.h</code>, подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#luado">5.8</a>.</p>

  <p>Единственный параметр <code>_ERRORMESSAGE</code>: строка, описывающая ошибку. Заданное по умолчанию определение для этого: обращение к функции <a name="_ALERT"></a><code>_ALERT</code>, которая печатает сообщение на <code>stderr</code>. Стандартная библиотека ввода-вывода переопределяет <code>_ERRORMESSAGE</code> и использует средства отладки, чтобы печатать некоторую дополнительную информацию, типа расположения обращений в стеке.</p>

  <p>Lua-код может явно генерировать ошибку, вызывая функцию <code>error</code> (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#pdf-error">6.1</a>). Lua-код может перехватить ошибку, используя обращение к функции <code>call</code> (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#pdf-call">6.1</a>). <a name="tag-method"></a></p>

  <h2>4.8 Методы тэгов</h2>

  <p>Lua обеспечивает мощный механизм, чтобы расширить семантику, названный <em>методами тэгов</em>. Это определенная программистом функция, которая вызвана в специфических точках в течение выполнения программы Lua, позволяя программисту изменить стандартное поведение Lua в этих точках. Каждая из этих точек названа событием (<a name="event"><em>event</em></a>).</p>

  <p>Метод тэга для некоего специфического события выбран согласно тэгу значения. Функция <a name="settagmethod"><tt>settagmethod</tt></a> изменяет метод тэга, связанный с данной парой <em>(tag, event)</em>. Первый параметр представляет собой тэг, второй строку (имя события), а третий параметр (функция) задает новый метод или <b>nil</b>, чтобы восстановить заданное по умолчанию поведение для пары. Функция <code>settagmethod</code> возвращает предыдущий метод тэга для этой пары. Функция-компаньон <a name="gettagmethod"><tt>gettagmethod</tt></a> получает тэг и имя события и возвращает текущий метод, связанный с парой.</p>

  <p>Методы тэгов вызваны при соответствующих событиях, которые идентифицированы данными именами. Семантика методов лучше объяснена функцией Lua, описывающей поведение интерпретатора в каждом событии. Эта функция не только показывает, когда метод вызван, но также параметры, результаты и заданное по умолчанию поведение. Код, показанный здесь, только иллюстративен: реальное поведение сложно закодировано в интерпретаторе и намного более эффективно, чем это моделирование. Все функции, используемые в этих описаниях (<code>rawget</code>, <code>tonumber</code>, <code>call</code> и т.д.), описаны подробно в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#predefined">6.1</a>.</p>

  <dl>
    <dt><b>&quot;add&quot;:</b></dt>

    <dd>
      <a name="add event"></a>Вызван, когда операция <code>+</code> применяется к не числовым операндам.

      <p>Функция <code>getbinmethod</code> ниже определяет, как Lua выбирает метод для двоичной операции. Сначала Lua пробует первый операнд. Если тэг не определяет метод для операции, то Lua пробует второй операнд. Если это также терпит неудачу, то Lua получает метод из тэга 0.</p>
      <pre>
function getbinmethod (op1, op2, event)
  return gettagmethod(tag(op1), event) or
         gettagmethod(tag(op2), event) or gettagmethod(0, event)
end
</pre>При использовании этой функции, метод события ``add&#39;&#39; такой:
      <pre>
function add_event (op1, op2)
  local o1, o2 = tonumber(op1), tonumber(op2)
  if o1 and o2 then  -- both operands are numeric
     return o1+o2  -- &#39;+&#39; here is the primitive &#39;add&#39;
  else  -- at least one of the operands is not numeric
    local tm = getbinmethod(op1, op2, &quot;add&quot;)
    if tm then
      -- call the method with both operands and an extra
      -- argument with the event name
      return tm(op1, op2, &quot;add&quot;)
    else  -- no tag method available: default behavior
      error(&quot;unexpected type at arithmetic operation&quot;)
    end
  end
end
</pre><br>
    </dd>

    <dt><b>&quot;sub&quot;:</b></dt>

    <dd><a name="sub event"></a>Вызван, когда операция <code>-</code> применяется к не числовым операндам. Поведение подобно событию ``add&#39;&#39;.<br>
    <br></dd>

    <dt><b>&quot;mul&quot;:</b></dt>

    <dd><a name="mul event"></a>Вызван, когда операция <code>*</code> применяется к не числовым операндам. Поведение подобно событию ``add&#39;&#39;.<br>
    <br></dd>

    <dt><b>&quot;div&quot;:</b></dt>

    <dd><a name="div event"></a>Вызван, когда операция <code>/</code> применяется к не числовым операндам. Поведение подобно событию ``add&#39;&#39;.<br>
    <br></dd>

    <dt><b>&quot;pow&quot;:</b></dt>

    <dd>
      <a name="pow event"></a>Вызван, когда операция <code>^</code> (возведение в степень) применяется к числовым операндам.
      <pre>
function pow_event (op1, op2)
  local tm = getbinmethod(op1, op2, &quot;pow&quot;)
  if tm then
    -- call the method with both operands and an extra
    -- argument with the event name
    return tm(op1, op2, &quot;pow&quot;)
  else  -- no tag method available: default behavior
    error(&quot;unexpected type at arithmetic operation&quot;)
  end
end
</pre><br>
    </dd>

    <dt><b>&quot;unm&quot;:</b></dt>

    <dd>
      <a name="unm event"></a>Вызван, когда одноместная операция <code>-</code> применяется к не числовому операнду.
      <pre>
function unm_event (op)
  local o = tonumber(op)
  if o then  -- operand is numeric
    return -o  -- &#39;-&#39; here is the primitive &#39;unm&#39;
  else  -- the operand is not numeric.
    -- Try to get a tag method from the operand;
    --  if it does not have one, try a &quot;global&quot; one (tag 0)
    local tm = gettagmethod(tag(op), &quot;unm&quot;) or
               gettagmethod(0, &quot;unm&quot;)
    if tm then
      -- call the method with the operand, nil, and an extra
      -- argument with the event name
      return tm(op, nil, &quot;unm&quot;)
    else  -- no tag method available: default behavior
      error(&quot;unexpected type at arithmetic operation&quot;)
    end
  end
end
</pre><br>
    </dd>

    <dt><b>&quot;lt&quot;:</b></dt>

    <dd>
      <a name="lt event"></a>Вызван, когда операция порядка применяется к не числовому или не строчному операнду. Это соответствует оператору <code>&lt;</code>.
      <pre>
function lt_event (op1, op2)
  if type(op1) == &quot;number&quot; and type(op2) == &quot;number&quot; then
     return op1 &lt; op2   -- numeric comparison
  elseif type(op1) == &quot;string&quot; and type(op2) == &quot;string&quot; then
    return op1 &lt; op2   -- lexicographic comparison
  else local tm = getbinmethod(op1, op2, &quot;lt&quot;)
    if tm then return tm(op1, op2, &quot;lt&quot;)
    else error(&quot;unexpected type at comparison&quot;);
    end
  end
end
</pre>Другие операторы порядка используют этот метод согласно обычным эквивалентностям:
      <pre>
a&gt;b    &lt;=&gt;  b&lt;a
a&lt;=b   &lt;=&gt;  not (b&lt;a)
a&gt;=b   &lt;=&gt;  not (a&lt;b)
</pre>
    </dd>

    <dt><b>&quot;concat&quot;:</b></dt>

    <dd>
      <a name="concatenation event"></a>Вызван, когда конкатенация применяется к не строчным операндам.
      <pre>
function concat_event (op1, op2)
  if (type(op1) == &quot;string&quot; or type(op1) == &quot;number&quot;) and
     (type(op2) == &quot;string&quot; or type(op2) == &quot;number&quot;) then
     return op1..op2  -- primitive string concatenation
  else local tm = getbinmethod(op1, op2, &quot;concat&quot;)
    if tm then return tm(op1, op2, &quot;concat&quot;)
    else error(&quot;unexpected type for concatenation&quot;)
    end
  end
end
</pre><br>
    </dd>

    <dt><b>&quot;index&quot;:</b></dt>

    <dd><a name="index event"></a>Вызван, когда Lua пробует найти значение индекса, не представленного в таблице.<br>
    <br></dd>

    <dt><b>&quot;getglobal&quot;:</b></dt>

    <dd>
      <a name="getglobal event"></a>Вызван всякий раз, когда Lua нуждается в значении глобальной переменной. Этот метод может быть установлен только для <b>nil</b> и для тэгов, порожденных вызовом <code>newtag</code>. Обратите внимание, что тэг представляет собой <em>текущее значение</em> глобальной переменной.
      <pre>
function getglobal (varname)
  -- access the table of globals
  local value = rawget(globals(), varname)
  local tm = gettagmethod(tag(value), &quot;getglobal&quot;)
  if not tm then return value
  else return tm(varname, value)
  end
end
</pre>Функция <code>getglobal</code> определена в базисной библиотеке.<br>
      <br>
    </dd>

    <dt><b>&quot;setglobal&quot;:</b></dt>

    <dd>
      <a name="setglobal event"></a>Вызван всякий раз, когда Lua присваивает значение глобальной переменной. Этот метод не может быть установлен для чисел, строк, таблиц и userdata с заданным по умолчанию тэгом.
      <pre>
function setglobal (varname, newvalue)
  local oldvalue = rawget(globals(), varname)
  local tm = gettagmethod(tag(oldvalue), &quot;setglobal&quot;)
  if not tm then rawset(globals(), varname, newvalue)
  else tm(varname, oldvalue, newvalue)
  end
end
</pre>Функция <code>setglobal</code> определена в базисной библиотеке.<br>
      <br>
    </dd>

    <dt><b>&quot;gettable&quot;:</b></dt>

    <dd>
      <a name="gettable event"></a>Вызван всякий раз, когда Lua обращается к индексированной переменной. Этот метод не может быть установлен для таблиц с заданным по умолчанию тэгом.
      <pre>
function gettable_event (table, index)
  local tm = gettagmethod(tag(table), &quot;gettable&quot;)
  if tm then return tm(table, index)
  elseif type(table) ~= &quot;table&quot; then
    error(&quot;indexed expression not a table&quot;);
  else local v = rawget(table, index)
    tm = gettagmethod(tag(table), &quot;index&quot;)
    if v == nil and tm then return tm(table, index)
    else return v
    end
  end
end
</pre><br>
    </dd>

    <dt><b>&quot;settable&quot;:</b></dt>

    <dd>
      <a name="settable event"></a>Вызван, когда Lua присваивает значение индексированной переменной. Этот метод не может быть установлен для таблиц с заданным по умолчанию тэгом.
      <pre>
function settable_event (table, index, value)
  local tm = gettagmethod(tag(table), &quot;settable&quot;)
  if tm then tm(table, index, value)
  elseif type(table) ~= &quot;table&quot; then error(&quot;indexed expression not a table&quot;)
  else rawset(table, index, value)
  end
end
</pre><br>
    </dd>

    <dt><b>&quot;function&quot;:</b></dt>

    <dd>
      <a name="function event"></a>Вызван, когда Lua пробует вызывать не функциональное значение.
      <pre>
function function_event (func, ...)
  if type(func) == &quot;function&quot; then return call(func, arg)
  else local tm = gettagmethod(tag(func), &quot;function&quot;)
    if tm then for i=arg.n,1,-1 do arg[i+1] = arg[i]
      end
      arg.n = arg.n+1
      arg[1] = func
      return call(tm, arg)
    else error(&quot;call expression not a function&quot;)
    end
  end
end
</pre><br>
    </dd>

    <dt><b>&quot;gc&quot;:</b></dt>

    <dd>
      <a name="gc event"></a>Вызван, когда Lua начинает уборку мусора в userdata. Этот метод может быть установлен только из C, и не может быть установлен для userdata с заданным по умолчанию тэгом. Для каждого объекта userdata, который будет собран, Lua делает эквивалент следующей функции в цикле уборки мусора:
      <pre>
function gc_event (obj)
  local tm = gettagmethod(tag(obj), &quot;gc&quot;)
  if tm then tm(obj)
  end
end
</pre>В цикле уборки мусора методы тэгов для userdata вызываются в порядке, <em>обратном</em> созданию тэгов, то есть первые методы, которые будут вызваны, связаны с последним тэгом, созданным в программе. Кроме того, в конце цикла Lua делает эквивалент обращения <code>gc_event(nil)</code>.
    </dd>
  </dl>

  <h1>5 API</h1><a name="C API"></a>Этот раздел описывает API для Lua, то есть набор функций C, доступных ведущей программе, чтобы связаться с Lua. Все функции API, связанные типы и константы объявлены в файле заголовка <code>lua.h</code>.

  <p>Даже когда используем термин &quot;функция&quot;, любое средство в API можно обеспечить как <em>макрокоманду</em>. Все такие макрокоманды используют каждый из параметров точно однажды и не генерируют скрытые побочные эффекты. <a name="mangstate"></a></p>

  <h2>5.1 Состояния</h2>

  <p>Библиотека Lua полностью повторно используема: она не имеет никаких глобальных переменных. Все состояние интерпретатора Lua (глобальные переменные, стек, методы тэгов и т.д.) сохранено в динамически распределенной структуре типа <a name="state"></a><a name="lua_State"></a><code>lua_State</code>. Это состояние должно быть передано как первый параметр каждой функции в библиотеке (за исключением <code>lua_open</code>).</p>

  <p>Перед вызовом любой функции API, Вы должны создать состояние вызовом: <a name="lua_open"></a></p>
  <pre>
lua_State *lua_open (int stacksize);
</pre>Единственный параметр этой функции: размер стека для интерпретатора. Каждое обращение к функции нуждается в одной позиции стека для каждого параметра, локальной переменной и временного значения, плюс по одной позиция для бухгалтерии. Стек должен также иметь приблизительно 20 позиций дополнительного пространства доступными. Для очень маленьких реализаций, без применения рекурсивных функций, размер стека в 100 должен быть достаточным. Если параметр <code>stacksize</code> равен 0, то используется заданный по умолчанию размер в 1024.

  <p>Чтобы освободить состояние, созданное <code>lua_open</code>, вызовите: <a name="lua_close"></a></p>
  <pre>
void lua_close (lua_State *L);
</pre>Эта функция уничтожает все объекты в данной среде Lua (вызывая соответствующие методы тэгов для уборки мусора, если они есть) и освобождает всю динамическую память, используемую этим состоянием. Обычно Вы не должны вызвать эту функцию потому, что все ресурсы естественно освобождены, когда Ваша программа заканчивается. С другой стороны, долго работающие программы должны бы освобождать ресурсы как только они становятся ненужными, чтобы не становиться слишком большими.

  <p>За исключением <code>lua_open</code> все функции в Lua API нуждаются в состоянии как в первом параметре. </p>

  <h2>5.2 Стек и индексы</h2>

  <p>Lua использует стек (<em>stack</em>), чтобы передавать значения в и из C. Каждый элемент в этом стеке представляет значение Lua (nil, число, строка).</p>

  <p>Для удобства большинство операций запроса в API не следует за строгой дисциплиной стека. Вместо этого они могут обратиться к любому элементу в стеке, используя индекс: положительный индекс представляет абсолютную позицию стека (начиная с 1, а не с 0, как в C). Отрицательный индекс представляет смещение от верхней части стека. Более определенно, если стек имеет <em>n</em> элементов, индекс 1 представляет первый элемент (то есть, первый элемент, помещенный в стек), а индекс <em>n</em> представляет последний элемент. Индекс <i>-1</i> также представляет последний элемент (то есть, элемент наверху), и индекс <i>-n</i> представляет первый элемент. Мы говорим, что индекс имеет силу, если он находится между 1 и верхней частью стека (то есть, если <code>1 &lt;= abs(index) &lt;= top</code>). <a name="stack index"></a><a name="valid index"></a></p>

  <p>В любое время Вы можете получать индекс верхнего элемента вызовом: <a name="lua_gettop"></a></p>
  <pre>
int lua_gettop (lua_State *L);
</pre>Потому, что начало индексов в 1, результат <code>lua_gettop</code> равно числу элементов в стеке (0 стало быть означает пустой стек).

  <p>Когда Вы взаимодействуете с Lua API, Вы ответственны за контроль переполнения стека. Функция <a name="lua_stackspace"></a></p>
  <pre>
int lua_stackspace (lua_State *L);
</pre>возвращает число доступных позиций стека. Всякий раз, когда Lua вызывается C, это гарантирует, что по крайней мере <code>LUA_MINSTACK</code> позиций все еще доступны. <code>LUA_MINSTACK</code> определен в файле заголовка <code>lua.h</code> и по крайней мере 16, так что Вы должны позаботиться о месте в стеке только, когда Ваш код имеет циклы, помещающие элементы в стек.

  <p>Большинство функций запроса принимает как индексы любое значение внутри доступного места в стеке. Такие индексы названы <em>приемлемыми индексами</em> . Более формально можно определять приемлемый индекс таким образом: <a name="acceptable index"></a></p>
  <pre>
(index &lt; 0 &amp;&amp; abs(index) &lt;= top) ||
(index &gt; 0 &amp;&amp; index &lt;= top + stackspace)
</pre>Обратите внимание, что 0 не является приемлемым индексом. 

  <h2>5.3 Манипуляции со стеком</h2>API предлагает следующие функции для базисного манипулирования стеком: <a name="lua_settop"></a><a name="lua_pushvalue"></a><a name="lua_remove"></a><a name="lua_insert"></a>
  <pre>
void lua_settop(lua_State *L, int index);
void lua_pushvalue(lua_State *L, int index);
void lua_remove(lua_State *L, int index);
void lua_insert(lua_State *L, int index);
</pre>

  <p><code>lua_settop</code> принимает любые приемлемые индексы или 0 и устанавливает верхнюю часть стека к этому индексу. Если новая верхняя часть больше, чем старая, то новые элементы заполнены <b>nil</b>. Если <code>index</code> равен 0, то все элементы из стека будут удалены. Полезная макрокоманда, определенная в API:</p>
  <pre>
#define lua_pop(L,n) lua_settop(L, -(n)-1)
</pre>выталкивает <code>n</code> элементов из стека.

  <p><code>lua_pushvalue</code> помещает в стек <em>копию</em> элемента в данном индексе. <code>lua_remove</code> удаляет элемент в данной позиции, сдвигая элементы вверх от этой позиции, чтобы заполнить промежуток. <code>lua_insert</code> перемещает верхний элемент в данную позицию, сдвигая элементы вверх от позиции на открытое место. Эти функции принимают только имеющие силу индексы. Как пример, если стек хранит значения (снизу вверх) <code>10 20 30 40 50</code>:</p>
  <pre>
lua_pushvalue(L, 3)  --&gt; 10 20 30 40 50 30
lua_pushvalue(L, -1) --&gt; 10 20 30 40 50 30 30
lua_remove(L, -3)    --&gt; 10 20 30 40 30 30
lua_remove(L,  6)    --&gt; 10 20 30 40 30
lua_insert(L,  1)    --&gt; 30 10 20 30 40
lua_insert(L, -1)    --&gt; 30 10 20 30 40  (никакого эффекта нет)
lua_settop(L, -3)    --&gt; 30 10 20
lua_settop(L, 6)     --&gt; 30 10 20 nil nil nil
</pre>

  <h2>5.4 Запросы к стеку</h2>

  <p>Чтобы проверять тип элемента стека, следующие функции доступны: <a name="lua_type"></a><a name="lua_tag"></a><a name="lua_isnil"></a><a name="lua_isnumber"></a><a name="lua_isstring"></a><a name="lua_istable"></a><a name="lua_isfunction"></a><a name="lua_iscfunction"></a><a name="lua_isuserdata"></a></p>
  <pre>
int lua_type(lua_State *L, int index);
int lua_tag(lua_State *L, int index);
int lua_isnil(lua_State *L, int index);
int lua_isnumber(lua_State *L, int index);
int lua_isstring(lua_State *L, int index);
int lua_istable(lua_State *L, int index);
int lua_isfunction(lua_State *L, int index);
int lua_iscfunction(lua_State *L, int index);
int lua_isuserdata(lua_State *L, int index);
</pre>Эти функции могут быть вызваны с любым приемлемым индексом.

  <p><code>lua_type</code> возвращает одну из следующих констант, согласно типу данного объекта: <code>LUA_TNIL</code>, <code>LUA_TNUMBER</code>, <code>LUA_TSTRING</code>, <code>LUA_TTABLE</code>, <code>LUA_TFUNCTION</code>, <code>LUA_TUSERDATA</code>. Если индекс не имеет силу (то есть, если та позиция стека пуста), то <code>lua_type</code> возвращает <code>LUA_TNONE</code>. Эти константы могут быть преобразованы в строки с помощью вызова:<a name="lua_typename"></a></p>
  <pre>
const char *lua_typename(lua_State *L, int t);
</pre>здесь <code>t</code> представляет собой тип, возвращенный <code>lua_type</code>. Строки, возвращаемые <code>lua_typename</code>: <code>&quot;nil&quot;</code>, <code>&quot;number&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;table&quot;</code>, <code>&quot;function&quot;</code>, <code>&quot;userdata&quot;</code> и <code>&quot;no value&quot;</code>,

  <p><code>lua_tag</code> возвращает тэг значения или <code>LUA_NOTAG</code> для не имеющего силу индекса.</p>

  <p>Функция <code>lua_is*</code> возвращает 1, если объект совместим с данным типом, и 0 в противном случае. Всегда возвращается 0 для не имеющего силу индекса. <code>lua_isnumber</code> принимает числа и числовые строки. <code>lua_isstring</code> берет строки и числа и <code>lua_isfunction</code> воспринимает функции Lua и C. Чтобы различать между функциями Lua и функциями C, Вы должны использовать <code>lua_iscfunction</code>. Чтобы различать между числами и числовыми строками, Вы можете использовать <code>lua_type</code>.</p>

  <p>API также имеет функции, чтобы сравнить два значения в стеке: <a name="lua_equal"></a><a name="lua_lessthan"></a></p>
  <pre>
int lua_equal(lua_State *L, int index1, int index2);
int lua_lessthan(lua_State *L, int index1, int index2);
</pre>Эти функции эквивалентны их дубликатам в Lua. Определенно, <code>lua_lessthan</code> эквивалентна <code>lt_event</code>. Обе функции возвращают 0, если любой из индексов не имеет силу.

  <p>Чтобы транслировать значение в стеке к специфическому типу C, Вы можете использовать следующие функции преобразования: <a name="lua_tonumber"></a><a name="lua_tostring"></a><a name="lua_strlen"></a><a name="lua_tocfunction"></a><a name="lua_touserdata"></a></p>
  <pre>
double  lua_tonumber(lua_State *L, int index);
const char *lua_tostring(lua_State *L, int index);
size_t lua_strlen(lua_State *L, int index);
lua_CFunction lua_tocfunction(lua_State *L, int index);
void *lua_touserdata(lua_State *L, int index);
</pre>Эти функции могут быть вызваны с любым приемлемым индексом. Когда вызваны с не имеющим силу индексом, они действуют так, как будто переданное им значение имело неправильный тип.

  <p><code>lua_tonumber</code> преобразовывает значение в данном индексе к числу с плавающей запятой. Это значение должно быть числом или строкой, обратимой в число (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#coercion">2</a>). Иначе <code>lua_tonumber</code> возвращает 0.</p>

  <p><code>lua_tostring</code> преобразовывает значение Lua в строку (<code>const char*</code>). Это значение должно быть числом или строкой, иначе будет возвращен <code>NULL</code>. Эта функция возвращает указатель на строку внутри Lua-среды. Эти строки всегда имеют ноль (<code>&#39;\0&#39;</code>) после их последнего символа (как в C), но могут содержать другие ноли в их теле. Если Вы не знаете, может ли строка содержать ноли, Вы должны использовать <code>lua_strlen</code>, чтобы получить фактическую длину. Потому, что Lua имеет мусороуборщик, не имеется никакой гарантии, что указатель, возвращенный <code>lua_tostring</code>, будет иметь силу после того, как соответствующее значение удалено из стека.</p>

  <p><code>lua_tocfunction</code> преобразовывает значение в стеке к функции C. Это значение должно быть функцией C, иначе <code>lua_tocfunction</code> возвращает <code>NULL</code>. Тип <code>lua_CFunction</code> рассмотрен более подробно в отдельном разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#LuacallC">5.13</a>.</p>

  <p><code>lua_touserdata</code> преобразовывает значение в <code>void*</code>. Это значение должно иметь тип <em>userdata</em>, иначе <code>lua_touserdata</code> вернет <code>NULL</code>. </p>

  <h2>5.5 Помещение значений в стек</h2>

  <p>API имеет следующие функции, чтобы поместить значения C в стек: <a name="lua_pushnumber"></a><a name="lua_pushlstring"></a><a name="lua_pushstring"></a><a name="lua_pushcfunction"></a><a name="lua_pushusertag"></a><a name="pushing"></a><a name="lua_pushnil"></a><a name="lua_pushuserdata"></a></p>
  <pre>
void lua_pushnumber(lua_State *L, double n);
void lua_pushlstring(lua_State *L, const char *s, size_t len);
void lua_pushstring(lua_State *L, const char *s);
void lua_pushusertag(lua_State *L, void *u, int tag);
void lua_pushnil(lua_State *L);
void lua_pushcfunction(lua_State *L, lua_CFunction f);
</pre>Эти функции получают значение C, преобразовывают его в соответствующее значение Lua, и помещают результат в стек. В частности, <code>lua_pushlstring</code> и <code>lua_pushstring</code> делают <em>внутреннюю копию</em> данной строки. <code>lua_pushstring</code> может использоваться только, чтобы поместить соответствующие C-строки (то есть, такие строки, которые заканчиваются нолем и не содержат вложенные ноли), иначе Вы должны использовать более общую функцию <code>lua_pushlstring</code>, которая принимает явный размер данных. <a name="GC"></a>

  <h2>5.6 Уборка мусора</h2>

  <p>Lua использует два числа, чтобы управлять совокупностью мусора. Одно число рассчитывает, сколько байтов динамической памяти Lua использует, а другое задает порог. Это внутренний счетчик байтов, сохраняемый Lua не полностью аккуратно: это может отклоняться на 10% от реального положения дел в памяти. Когда число байтов пересекает порог, Lua выполняет цикл зачистки мусора, который исправляет память и стирает оттуда все отработавшие свое, но забытые там объекты (то есть объекты, больше доступные из Lua). Счетчик байтов будет исправлен, а затем порог сброшен к двойному значению счетчика байтов.</p>

  <p>Вы можете обращаться к текущим значениям этих двух чисел через следующие функции: <a name="lua_getgcthreshold"></a><a name="lua_getgccount"></a></p>
  <pre>
int lua_getgccount (lua_State *L);
int lua_getgcthreshold (lua_State *L);
</pre>Оба возвращают их соответствующие значения в килобайтах. Вы можете изменять пороговое значение с помощью: <a name="lua_setgcthreshold"></a>
  <pre>
void  lua_setgcthreshold (lua_State *L, int newthreshold);
</pre>Снова значение <code>newthreshold</code> задано в килобайтах. Когда Вы вызываете эту функцию, Lua устанавливает новый порог и проверяет счетчик байтов. Если новый порог меньше, чем счетчик байтов, то Lua немедленно выполняет уборку мусора. После нее новый порог будет установлен согласно предыдущему правилу.

  <p>Если Вы хотите изменять поведение коллектора мусора адаптивно, Вы можете использовать метод тэга мусоросборщика для <b>nil</b>, чтобы установить ваш собственный порог (метод тэга будет вызван после того, как Lua сбрасывает порог). <a name="C-tags"></a></p>

  <h2>5.7 Userdata и тэги</h2>

  <p>Поскольку userdata представляют собой объекты, функция <code>lua_pushusertag</code> может создавать новые userdata. Если Lua имеет userdata с данным значением (<code>void*</code>) и тэг, то этот объект размещен. Иначе создается новый userdata с данным значением и тэгом. Если эта функция вызвана с тэгом, равным <code>LUA_ANYTAG</code> <a name="LUA_ANYTAG"></a>, то Lua пробует находить любой объект userdata с данным значением, независимо от его тэга. Если не имеется никакого userdata с этим значением, то новый объект будет создан с тэгом, равным 0.</p>

  <p>Userdata может иметь различные тэги, чья семантика известна только ведущей программе. Тэги создаются функцией: <a name="lua_newtag"></a></p>
  <pre>
int lua_newtag (lua_State *L);
</pre>Функция <code>lua_settag</code> меняет тэг объекта в верхней части стека (без того, чтобы получить его): <a name="lua_settag"></a>
  <pre>
void lua_settag (lua_State *L, int tag);
</pre>Объект должен быть userdata или таблицей, данный тэг должен быть значением, созданным с помощью функции <code>lua_newtag</code>. <a name="luado"></a>

  <h2>5.8 Выполнение Lua-кода</h2>Ведущая программа может выполнять Lua-chunk, записанные в файле или в строке, используя следующие функции: <a name="lua_dofile"></a><a name="lua_dostring"></a><a name="lua_dobuffer"></a>
  <pre>
int lua_dofile(lua_State *L, const char *filename);
int lua_dostring(lua_State *L, const char *string);
int lua_dobuffer(lua_State *L, const char *buff, size_t size,
                 const char *name);
</pre>Эти функции возвращают 0 в случае успеха, или один из следующих кодов ошибки, если они терпят неудачу:

  <ul>
    <li><a name="LUA_ERRRUN"><tt>LUA_ERRRUN</tt></a>: ошибка при управлении chunk.</li>

    <li><a name="LUA_ERRSYNTAX"><tt>LUA_ERRSYNTAX</tt></a>: ошибка синтаксиса в течение прекомпиляции.</li>

    <li><a name="LUA_ERRMEM"><tt>LUA_ERRMEM</tt></a>: ошибка распределения памяти. Для таких ошибок, Lua не вызывает <code>_ERRORMESSAGE</code> (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#error">4.7</a>).</li>

    <li><a name="LUA_ERRERR"><tt>LUA_ERRERR</tt></a>: ошибка при управлении <code>_ERRORMESSAGE</code>. Для таких ошибок Lua не вызывает <code>_ERRORMESSAGE</code> снова, чтобы избежать циклов.</li>

    <li><a name="LUA_ERRFILE"><tt>LUA_ERRFILE</tt></a>: ошибка открытия файла (только для <code>lua_dofile</code>). В этом случае Вы можете проверять <code>errno</code>, вызывая <code>strerror</code> или <code>perror</code>, чтобы сообщить пользователю, что пошло неправильно.</li>
  </ul>Эти константы определены в <code>lua.h</code>.

  <p>Когда функция <code>lua_dofile</code> вызвана с параметром <code>NULL</code>, она выполняет поток <code>stdin</code>. <code>lua_dofile</code> и <code>lua_dobuffer</code> способны выполнить прекомпилируемые объекты кода. Они автоматически обнаруживают, является ли кусок кода текстовым или двоичным, и загружают его соответственно. <code>lua_dostring</code> выполняет только исходный текст, заданный в простой текстовой форме.</p>

  <p>Третий параметр для <code>lua_dobuffer</code> задает имя chunk, который используется сообщениях об ошибках и отладочных сообщениях. Если имя <code>name</code> равно <code>NULL</code>, то Lua дает заданное по умолчанию имя этому chunk.</p>

  <p>Эти функции помещают в стек любые значения, в конечном счете возвращенные кодом. Код может возвращать любое число значений; Lua соблюдает осторожность, в том плане, что эти значения вписываются в размер стека, но после обращения ответственность переходит к Вам. Если Вы должны поместить другие элементы после вызова любой из этих функций, и Вы хотите работать спокойно, Вы должны или проверить место в стеке с помощью <code>lua_stackspace</code>, или удалять возвращенные элементы из стека (если Вы не нуждаетесь в них). Например, следующий код загружает код в файле и отбрасывает все результаты, возвращенные этим кодом:</p>
  <pre>
{
  int oldtop = lua_gettop(L);
  lua_dofile(L, filename);
  lua_settop(L, oldtop);
}
</pre>

  <h2>5.9 Управление глобальными переменными в Lua</h2>

  <p>Чтобы прочитать значение глобальной переменной Lua, надо: <a name="lua_getglobal"></a></p>
  <pre>
void lua_getglobal (lua_State *L, const char *varname);
</pre>Это помещает в стек значение данной переменной. Как в Lua эта функция может вызывать метод тэга для события getglobal. Чтобы читать реальное значение глобальной переменной без того, чтобы вызывать любой метод тэга, используют <code>lua_rawget</code> над таблицей глобальных переменных.

  <p>Чтобы записать значение в глобальнукю переменную: <a name="lua_setglobal"></a></p>
  <pre>
void lua_setglobal (lua_State *L, const char *varname);
</pre>Это извлекает из стека значение, которое будет сохранено в данной переменной. Как в Lua эта функция может вызывать метод тэга для события setglobal. Чтобы устанавливать реальное значение глобальной переменной без того, чтобы вызывать любой метод тэга, используют <code>lua_rawset</code> над таблицей глобальных переменных (подробности приведены ниже).

  <p>Все глобальные переменные сохраняются в обычной Lua-таблице. Вы можете получать ее вызовом: <a name="lua_getglobals"></a></p>
  <pre>
void lua_getglobals (lua_State *L);
</pre>Это помещает текущую (актуальную) таблицу глобальных переменных в стек. Чтобы устанавливать другую таблицу глобальных переменных, используйте вызов: <a name="lua_setglobals"></a>
  <pre>
void lua_setglobals (lua_State *L);
</pre>Таблица, которую нужно использовать, извлекается из стека. 

  <h2>5.10 Управление таблицами в Lua</h2>Lua-таблицы могут также управляться через API.

  <p>Чтобы читать значение в таблице, таблица должна находиться где-нибудь в стеке. Теперь вызовите <a name="lua_gettable"></a></p>
  <pre>
void lua_gettable (lua_State *L, int index);
</pre>где <code>index</code> относится к таблице. <code>lua_gettable</code> извлекает ключ из стека и возвращает (через стек) содержание таблицы для заданного ключа. Как в Lua эта операция может вызывать метод тэга для события gettable. Получать реальное значение любого ключа таблицы, без того, чтобы вызывать любой метод тэга, можно, используя <a name="lua_rawget"></a>
  <pre>
void lua_rawget (lua_State *L, int index);
</pre>

  <p>Чтобы сохранять значение в таблицу, которая находится где-нибудь в стеке, Вы помещаете ключ и значение в стек (именно в этом порядке!), а затем вызываете такое обращение: <a name="lua_settable"></a></p>
  <pre>
void lua_settable (lua_State *L, int index);
</pre>здесь <code>index</code> относится к таблице. <code>lua_settable</code> извлекает из стека ключ и значение. Как и все в Lua, эта операция может вызывать метод тэга для события settable. Чтобы устанавливать реальное значение любого индекса таблицы без того, чтобы вызывать любой метод тэга, используют <em>raw</em>-версию: <a name="lua_rawset"></a>
  <pre>
void lua_rawset (lua_State *L, int index);
</pre>

  <p>В заключение, еще одна функция <a name="lua_newtable"></a></p>
  <pre>
void lua_newtable (lua_State *L);
</pre>создает новую, пустую, таблицу и помещает ее в стек. 

  <h2>5.11 Использование таблиц как массивов</h2>API имеет функции, которые помогают использовать таблицы Lua как массивы, то есть таблицы, индексированные только числами: <a name="lua_rawgeti"></a><a name="lua_rawseti"></a><a name="lua_getn"></a>
  <pre>
void lua_rawgeti(lua_State *L, int index, int n);
void lua_rawseti(lua_State *L, int index, int n);
int lua_getn(lua_State *L, int index);
</pre>

  <p><code>lua_rawgeti</code> получает значение энного элемента таблицы в позиции <code>index</code> стека.</p>

  <p><code>lua_rawseti</code> устанавливает значение энного элемента таблицы в позиции <code>index</code> стека к значению наверху стека.</p>

  <p><code>lua_getn</code> возвращает число элементов в таблице в позиции <code>index</code>. Это число представляет собой значение поля <code>n</code> таблицы, если это имеет числовое значение, или самый большой числовой индекс со значением non-nil в таблице. </p>

  <h2>5.12 Вызов функций Lua</h2>

  <p>Функции, определенные в Lua (и функции C, зарегистрированные в Lua), могут быть вызваны из ведущей программы. Это выполнено, используя следующий протокол: сначала, функция, которая будет вызвана, помещена в стек, затем, параметры функции помещены в прямом порядке, то есть первый параметр помещен в стек первым. В заключение, функция вызвана: <a name="lua_call"></a></p>
  <pre>
int lua_call (lua_State *L, int nargs, int nresults);
</pre>Эта функция возвращает те же самые коды ошибки, что и <code>lua_dostring</code> и другие (подробности в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#luado">5.8</a>). Если Вы хотите исследовать ошибку, вместо того, чтобы возвратить код ошибки, используйте: <a name="lua_rawcall"></a>
  <pre>
void lua_rawcall(lua_State *L, int nargs, int nresults);
</pre>

  <p>В обеих функциях <code>nargs</code> задает число параметров, которые Вы поместили в стек. Все параметры и функциональное значение берутся из стека, а функциональные результаты помещены туда. Число результатов будет откорректировано до <code>nresults</code>, если <code>nresults</code> не <a name="LUA_MULTRET"><tt>LUA_MULTRET</tt></a>. В этом случае <em>все</em> результаты функции будут помещены в стек. Функциональные результаты помещены в прямом порядке (первый результат и помещен первым), чтобы после обращения последний результат оказался на самой вершине стека.</p>

  <p>Следующий пример показывает, как ведущая программа может делать эквивалент коду на Lua:</p>
  <pre>
a,b = f(&quot;how&quot;, t.x, 4)
</pre>Here it is in C:
  <pre>
lua_getglobal(L, &quot;t&quot;);    /* глобальная `t&#39; (потом пригодится) */
lua_getglobal(L, &quot;f&quot;);    /* функция, которая будет вызвана */
lua_pushstring(L, &quot;how&quot;); /* 1-ый параметр */
lua_pushstring(L, &quot;x&quot;);   /* помещает в стек строку `x&#39; */
lua_gettable(L, -4);      /* помещает в стек результат t.x (2-ой аргумент) */
lua_pushnumber(L, 4);     /* 3-ий параметр */
lua_call(L, 3, 2);    /* вызывает функцию с 3 параметрами и 2 результатами */
lua_setglobal(L, &quot;b&quot;);    /* устанавливает глобальную переменную `b&#39; */
lua_setglobal(L, &quot;a&quot;);    /* устанавливает глобальную переменную `a&#39; */
lua_pop(L, 1);            /* удаляет из стека `t&#39; */
</pre>Обратите внимание, что код выше сбалансированный: в конце стек обратен к первоначальной конфигурации. Это считается хорошей практикой.

  <p>Некоторые специальные функции Lua имеют собственные интерфейсы C. Ведущая программа может генерировать ошибку Lua, вызывая функцию: <a name="lua_error"></a></p>
  <pre>
void lua_error (lua_State *L, const char *message);
</pre>Эта функция никогда не возвращает ничего. Если <code>lua_error</code> вызвана из функции C, которая была вызвана из Lua, то соответствующий блок кода Lua завершается так, как будто ошибка произошла внутри кода Lua. Иначе вся ведущая программа завершается обращением <code>exit(EXIT_FAILURE)</code>. Перед завершением выполнения, сообщение <code>message</code> будет передано функции драйвера ошибки <code>_ERRORMESSAGE</code>. Если <code>message</code> равно <code>NULL</code>, то <code>_ERRORMESSAGE</code> не вызывается.

  <p>Методы тэгов могут быть изменены с <a name="lua_settagmethod"></a></p>
  <pre>
void lua_settagmethod (lua_State *L, int tag, const char *event);
</pre>Второй параметр задает тэг, а третий представляет собой имя события. Новый метод берется из стека. Чтобы получить текущее (актуальное) значение метода тэга используйте функцию <a name="lua_gettagmethod"></a>
  <pre>
void lua_gettagmethod(lua_State *L, int tag, const char *event);
</pre>

  <p>Также возможно копировать все методы из одного тэга в другой: <a name="lua_copytagmethods"></a></p>
  <pre>
int lua_copytagmethods (lua_State *L, int tagto, int tagfrom);
</pre>Эта функция вернет <code>tagto</code>.

  <p>Вы можете пересекать таблицу с функцией: <a name="lua_next"></a></p>
  <pre>
int lua_next (lua_State *L, int index);
</pre>здесь <code>index</code> относится к таблице, которая будет пересечена. Функция берет ключ из стека и помещает туда пару &quot;значение-ключ&quot; из таблицы (следующую после данного ключа). Если не имеется больше элементов, то функция возвращает 0 (и не помещает в стек ничего). Типичный пример использования выглядит следующим образом:
  <pre>
lua_pushnil(L);  /* first key */
while (lua_next(L, t) != 0) {
  /* `key&#39; is at index -2 and `value&#39; at index -1 */
  printf(&quot;%s - %s\n&quot;, lua_typename(L, lua_type(L, -2)),
         lua_typename(L, lua_type(L, -1)));
  lua_pop(L, 1);  /* removes `value&#39;; keeps `index&#39; for next iteration */
}
</pre>

  <p>Функция <a name="lua_concat"></a></p>
  <pre>
void lua_concat (lua_State *L, int n);
</pre>конкатенирует <code>n</code> значений сверху стека, извлекает их и оставляет результат наверху. Здесь <code>n</code> должно быть по крайней мере равно 2. Конкатенация выполнена по правилам обычной семантики Lua <a name="LuacallC"></a>

  <h2>5.13 Определение функций C</h2>Чтобы зарегистрировать функцию C в Lua, имеется следующая макрокоманда: <a name="lua_register"></a>
  <pre>
#define lua_register(L, n, f) (lua_pushcfunction(L, f), lua_setglobal(L, n))
/* const char *n;   */
/* lua_CFunction f; */
</pre>Которая получает имя, которое функция будет иметь в Lua, и указатель на функцию. Этот указатель должен иметь тип <code>lua_CFunction</code>, который определен так; <a name="lua_CFunction"></a>
  <pre>
typedef int (*lua_CFunction) (lua_State *L);
</pre>То есть, это указатель на функцию с целочисленным результатом и одиночным параметром, Lua-средой.

  <p>Чтобы связываться правильно с Lua, функция C должна следовать следующему протоколу, который определяет путь, которым параметры и результаты переданы: функция C получает параметры от Lua в стеке, в прямом порядке (первый параметр помещен первым). Чтобы возвращать значения Lua, функция C только помещает их в стек в прямом порядке и возвращает число результатов. Подобно функции Lua, функция C, вызванная Lua, может возвращать много результатов.</p>

  <p>Как пример, следующая функция получает переменное число числовых параметров, а возвращает их среднее и сумму:</p>
  <pre>
static int foo (lua_State *L) {
  int n = lua_gettop(L);    /* number of arguments */
  double sum = 0;
  int i;

  for (i = 1; i &lt;= n; i++) {
    if (!lua_isnumber(L, i))
       lua_error(L, &quot;incorrect argument to function `average&#39;&quot;);
    sum += lua_tonumber(L, i);
  }
  lua_pushnumber(L, sum/n);   /* первый результат */
  lua_pushnumber(L, sum);     /* второй результат */
  return 2;                   /* сколько всего результатов */
}
</pre>Эта функция может быть зарегистрирована в Lua как <code>average</code> таким вызовом:
  <pre>
lua_register(L, &quot;average&quot;, foo);
</pre>

  <p>Когда функция C создана, возможно сопоставить с ней некоторые <em>upvalues</em>, таким образом создавая замкнутое выражение C; эти значения будут переданы функции всякий раз, когда она вызвана, как обычные параметры. Чтобы сопоставить upvalues с функцией C, сначала эти значения должны быть помещены в стек. Затем функция <a name="lua_pushcclosure"></a></p>
  <pre>
void lua_pushcclosure (lua_State *L, lua_CFunction fn, int n);
</pre>используется, чтобы поместить функцию C в стек с параметром <code>n</code> означающим, сколько upvalues должно быть связан с функцией (эти upvalues берутся из стека). Фактически, макрокоманда <code>lua_pushcfunction</code> определена как <code>lua_pushcclosure</code> с <code>n</code> установленным в 0. Затем, всякий раз, когда функция C вызвана, эти upvalues вставлены как <em>последние</em> параметры функции, после фактических параметров, переданных в обращении. Это избавляет от необходимости выяснять, сколько параметров было передано фактически. Так <em>i</em>-th upvalue находится в стеке в индексе <i>i-(n+1)</i>, где <em>n</em> задает номер upvalues.

  <p>Для большего количества примеров функций C и замкнутых выражений изучите файлы <code>lbaselib.c</code>, <code>liolib.c</code>, <code>lmathlib.c</code> и <code>lstrlib.c</code> в дистрибутиве Lua. </p>

  <h2>5.14 Ссылки к Lua-объектам</h2>

  <p>Если C-код должен хранить значение Lua вне продолжительности жизни функции C, то надо создать <em>ссылку</em> к значению. Функции, чтобы управлять ссылками, следующие: <a name="reference"></a><a name="lua_ref"></a><a name="lua_getref"></a><a name="lua_unref"></a></p>
  <pre>
int lua_ref(lua_State *L, int lock);
int lua_getref(lua_State *L, int ref);
void lua_unref(lua_State *L, int ref);
</pre>

  <p><code>lua_ref</code> выталкивает значение из стека, создает ссылку к нему и возвращает эту ссылку. Для значения <b>nil</b> ссылка всегда <code>LUA_REFNIL</code>.<a name="LUA_REFNIL"></a> <code>lua.h</code> также определяет константу <code>LUA_NOREF</code><a name="LUA_NOREF"></a>, которая отличается от любой имеющей силу ссылки. Если <code>lock</code> не равно 0, то объект <em>блокирован</em>: это означает, что объект не будет обработан мусоросборщиком. Разблокированные ссылки могут быть удалены в порядке уборки мусора на общих основаниях.</p>

  <p>Всякий раз, когда вызванный объект необходим в C, обращение к <code>lua_getref</code> помещает тот объект в стек; если объект был убран, <code>lua_getref</code> вернет 0 (и не поместит ничего в стек).</p>

  <p>Когда ссылка больше не нужна, ее надо освободить вызовом <code>lua_unref</code>.</p>

  <h3>5.15 Системный реестр</h3>

  <p>При своем запуске Lua регистрируют таблицу в позиции <a name="LUA_REFREGISTRY"><tt>LUA_REFREGISTRY</tt></a>. К этому можно обращаться через макрокоманду: <a name="lua_getregistry"></a></p>
  <pre>
#define lua_getregistry(L) lua_getref(L, LUA_REFREGISTRY)
</pre>Эта таблица может использоваться C-библиотеками как общий механизм системного реестра. Любая C-библиотека может сохранять данные в этой таблице, пока она выбирает ключ регистрации, отличный от других библиотек. 

  <h1>6 Стандартные библиотеки</h1>

  <p>Стандартные библиотеки обеспечивают полезные функции, которые выполнены непосредственно через стандартный API. Следовательно, они не так уж и необходимы для самого языка, а обеспечиваются как отдельные C-модули. В настоящее время, Lua имеет следующие стандартные библиотеки:</p>

  <ul>
    <li>Базисная библиотека.</li>

    <li>Работа со строками.</li>

    <li>Различная математика (sin, log и т,п,).</li>

    <li>Ввод и вывод (плюс некоторые средства системы).</li>
  </ul>Чтобы иметь доступ к этим библиотекам, ведущая C-программа должна вызвать функции <code>lua_baselibopen</code>, <code>lua_strlibopen</code>, <code>lua_mathlibopen</code> и <code>lua_iolibopen</code>, которые объявлены в файле заголовков <code>lualib.h</code>. <a name="lua_baselibopen"></a><a name="lua_strlibopen"></a><a name="lua_mathlibopen"></a><a name="lua_iolibopen"></a><a name="predefined"></a>

  <h2>6.1 Базисные функции</h2>

  <p>Базисная библиотека обеспечивает некоторые основные функции для Lua. Следовательно, если Вы не включаете эту библиотеку в Вашей прикладной программе, Вы должны тщательно проверить, должны ли Вы обеспечить какую-то альтернативную реализацию для некоторых средств. Например, без функции <code>_ERRORMESSAGE</code> Lua не способен показать сообщения об ошибках. <a name="_alert"></a></p>

  <h3><tt>_ALERT (message)</tt></h3>Печатает только строковый аргумент на <a name="stderr"><tt>stderr</tt></a>. Все сообщения об ошибках в Lua напечатаны через функцию, сохраненную в глобальной переменной <code>_ALERT</code>. Следовательно, программа может назначать другую функцию к этой переменной, и изменять путь, которым такие сообщения показываются (например, для систем без <code>stderr</code>). <a name="assert"></a>

  <h3><tt>assert (v [, message])</tt></h3>Выдает ошибку <em>assertion failed!</em>, когда параметр <code>v</code> равен <b>nil</b>. Эта функция эквивалентна следующей функции Lua:
  <pre>
function assert(v, m)
  if not v then m = m or &quot;&quot;
     error(&quot;assertion failed!  &quot; .. m)
  end
end
</pre><a name="call"></a>

  <h3><tt>call (func, arg [, mode [, errhandler]])</tt></h3><a name="pdf-call"></a>Вызывает функцию <code>func</code> с параметрами, заданными таблицей <code>arg</code>. Обращение эквивалентно
  <pre>
func(arg[1], arg[2], ..., arg[n])
</pre>где <code>n</code> представляет собой результат <code>getn(arg)</code>. Все результаты из <code>func</code> просто возвращены <code>call</code>.

  <p>По умолчанию, если ошибка происходит в течение обращения к <code>func</code>, она объясняется подробно. Если строка <code>mode</code> включает <code>&quot;x&quot;</code>, то обращение <em>защищено</em>. В этом режиме обращение к функции не <code>call</code> не объясняет ошибку подробно, независимо от того, что случается в течение обращения. Вместо этого, это возвращает <b>nil</b>, чтобы сообщить об ошибке (помимо вызова приспособленного драйвера ошибки).</p>

  <p>Если <code>errhandler</code> обеспечивается, функция ошибки <code>_ERRORMESSAGE</code> временно установлена к <code>errhandler</code> на время выполнения <code>func</code>. В частности, если <code>errhandler</code> равен <b>nil</b>, никакие сообщения об ошибках не будут выданы в течение выполнения вызванной функции вообще. <a name="collectgarbage"></a></p>

  <h3><tt>collectgarbage ([limit])</tt></h3>

  <p>Устанавливает порог для мусоросборщика в данное значение (в Kbytes). Если новый порог меньше, чем счетчик байтов, то Lua немедленно выполняет уборку мусора в памяти. Если <code>limit</code> отсутствует, значением по умолчанию является ноль (таким образом уборка мусора запустится сразу).</p>

  <h3><tt>copytagmethods (tagto, tagfrom)</tt></h3><a name="copytagmethods"></a>Копирует все методы тэга из одного тэга в другой, возвращает <code>tagto</code>. <a name="dofile"></a>

  <h3><tt>dofile (filename)</tt></h3>Получает имя файла, открывает именованный файл и выполняет его содержимое как Lua-код или как прекомпилируемый код. Когда вызвано без параметров, <code>dofile</code> выполняет содержание стандартного ввода (<code>stdin</code>). Если имеется любая ошибка, <code>dofile</code> вернет <b>nil</b>. Иначе это возвращает значения, возвращенные кодом, или значение не-<b>nil</b>, если блок кода не возвращает никаких значений. Это выдает ошибку, когда вызвано не со строчным параметром. <a name="dostring"></a>

  <h3><tt>dostring (string [, chunkname])</tt></h3>Выполняет данную строку как код на Lua. Если имеется любая ошибка, то <code>dostring</code> вернет <b>nil</b>. Иначе это возвращает значения, возвращенные кодом, или значение не-<b>nil</b>, если код не возвращает никакие значения. Факультативный параметр <code>chunkname</code> имя кода, используемого для информации об ошибках и отладочных сообщений. <a name="pdf-error"></a> <a name="error"></a>

  <h3><tt>error (message)</tt></h3>Вызывает драйвер ошибки и затем завершает последнюю защищенную вызванную функцию (в C: <code>lua_dofile</code>, <code>lua_dostring</code>, <code>lua_dobuffer</code> или <code>lua_callfunction</code>, в Lua: <code>dofile</code>, <code>dostring</code> или <code>call</code> в защищенном режим). Если <code>message</code> равно <b>nil</b>, то драйвер ошибки не будет вызван. Функция <code>error</code> никогда ничего не возвращает. <a name="foreach"></a>

  <h3><tt>foreach (table, func)</tt></h3>Выполняется данную <code>func</code> над всеми элементами таблицы <code>table</code>. Для каждого элемента, функция вызвана с индексом и соответствующим значением как параметрами. Если функция возвращает любое значение не-<b>nil</b>, то цикл завершается, и это значение будет возвращено как конечное значение <code>foreach</code>. Эта функция могла бы быть определена в Lua так:
  <pre>
function foreach (t, f)
  for i, v in t do
    local res = f(i, v)
    if res then return res end
  end
end
</pre>Поведение <code>foreach</code> <em>неопределено</em>, если Вы изменяете таблицу <code>t</code> в ходе работ. <a name="foreachi"></a>

  <h3><tt>foreachi (table, func)</tt></h3>Выполняет данную <code>func</code> над числовыми индексами таблицы <code>table</code>. Для каждого индекса функция вызвана с индексом и соответствующим значением как параметрами. Индексы обрабатываются в последовательном порядке, от 1 до <code>n</code>, где <code>n</code> представляет собой результат <code>getn(table)</code>. Если функция возвращает любое значение не-<b>nil</b>, то цикл прерывается, а это значение будет возвращено как конечное значение <code>foreachi</code>. Эта функция могла бы быть определена в Lua таким образом:
  <pre>
function foreachi (t, f)
  for i=1,getn(t) do
    local res = f(i, t[i])
    if res then return res end
  end
end
</pre><a name="getglobal"></a>

  <h3><tt>getglobal (name)</tt></h3>Получает значение глобальной переменной или вызывает метод тэга для события getglobal. Полная семантика объясняется в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#tag-method">4.8</a> . Строка <code>name</code> задает имя переменной. <a name="getn"></a>

  <h3><tt>getn (table)</tt></h3>Возвращает размер таблицы, представленной как список. Если таблица имеет <code>n</code> полей с числовым значением, это количество и будет размером таблицы. Иначе размером является самый большой числовой индекс со значением не-nil в таблице. Эта функция могла бы быть определена в Lua так:
  <pre>
function getn (t)
  if type(t.n) == &quot;number&quot; then return t.n end
  local max = 0
  for i, _ in t do
    if type(i) == &quot;number&quot; and i&gt;max then max=i end
  end
  return max
end
</pre><a name="gettagmethod"></a>

  <h3><tt>gettagmethod (tag, event)</tt></h3>Возвращает текущий метод тэга для данной пары <em>(tag, event)</em>. Эта функция не может использоваться, чтобы получить метод тэга для события gc. Такие методы тэга могут управляться только C-кодом. <a name="globals"></a>

  <h3><tt>globals ([table])</tt></h3>Возвращает текущую таблицу глобальных переменных. Если параметр <code>table</code> задан, то это также устанавливает его как новую таблицу глобальных переменных. <a name="pdf-newtag"></a> <a name="newtag"></a>

  <h3><tt>newtag ()</tt></h3>Возвращает новый тэг. <a name="next"></a>

  <h3><tt>next (table, [index])</tt></h3>Позволяет программе пересекать все поля таблицы. Первый параметр: таблица, а второй параметр задает индекс в этой таблице. <code>next</code> вернет следующий индекс таблицы и значение, связанное с индексом. Когда вторым параметром является <b>nil</b>, <code>next</code> вернет первый индекс таблицы и связанное значение. При вызове с последним индексом или с <b>nil</b> в пустой таблице, <code>next</code> вернет <b>nil</b>. Если второй параметр отсутствует, то это интерпретируется как указание <b>nil</b>.

  <p>Lua не имеет никакого объявления полей: семантически не имеется никакого различия между полем, не представленным в таблице, или полем со значением <b>nil</b>. Следовательно, <code>next</code> рассматривает только поля со значениями не-<b>nil</b>. Порядок, в котором индексы перечислены, не определен даже для числовых индексов. Чтобы обработать таблицу в числовом порядке, надо использовать функцию foreachi.</p>

  <p>Поведение <code>next</code> <em>неопределено</em>, если Вы изменяете таблицу в ходе работ. <a name="print"></a></p>

  <h3><tt>print (e1, e2, ...)</tt></h3>Получает любое число параметров, и печатает их значения, используя строки, возвращенные <code>tostring</code>. Эта функция не предназначена для форматируемого вывода, ее следует рассматривать только как быстрый способ показать значение, например для отладки. <a name="rawget"></a>

  <h3><tt>rawget (table, index)</tt></h3>Получает реальное значение <code>table[index]</code> без того, чтобы вызвать любой метод тэга. Таблица должна быть задана как <code>table</code>, а <code>index</code> представляет собой любое значение, отличное от <b>nil</b>. <a name="rawset"></a>

  <h3><tt>rawset (table, index, value)</tt></h3>Устанавливает реальное значение <code>table[index]</code> в <code>value</code> без того, чтобы вызвать любой метод тэга. Параметр <code>table</code> должен быть таблицей, <code>index</code> представляет собой любое значение, отличное от <b>nil</b>, а <code>value</code> задает любое значение Lua. <a name="setglobal"></a>

  <h3><tt>setglobal (name, value)</tt></h3>Устанавливает именованную глобальную переменную к данному значению, или вызывает метод тэга для события setglobal. Полная семантика объясняется в разделе <a href="http://www.botik.ru/~rldp/mysql/mysqldev/glava04.htm#tag-method">8</a>. <a name="settag"></a>

  <h3><tt>settag (t, tag)</tt></h3>Устанавливает тэг данной таблицы. Тэг (<code>tag</code>) должен быть значением, созданным через <code>newtag</code>. <code>settag</code> вернет значение первого параметра (таблицу). Для безопасности ведущих программ невозможно изменить тэг userdata прямо из Lua.

  <h3><tt>settagmethod (tag, event, newmethod)</tt></h3><a name="settagmethod"></a>Устанавливает новый метод тэга к данной паре <em>(tag, event)</em> и возвращает старый метод. Если <code>newmethod</code> равно <b>nil</b>, то <code>settagmethod</code> восстанавливает заданное по умолчанию поведение для данного события. Эта функция не может использоваться, чтобы установить метод для события gc. Такие методы могут управляться только C-кодом. <a name="sort"></a>

  <h3><tt>sort(table [, comp])</tt></h3>Сортирует элементы таблицы в данном порядке, данные берутся из <code>table[1]</code> и помещаются в <code>table[n]</code>, где <code>n</code> представляет собой результат <code>getn(table)</code>. Если <code>comp</code> задан, то это должно быть функцией, которая получает два элемента таблицы и возвращает истину (то есть значение, отличное от <b>nil</b>), когда первый меньше, чем второй (так, чтобы <code>not comp(a[i+1], a[i])</code> был истиной после сортировки). Если <code>comp</code> не задано, то вместо этого используется стандартный оператор <code>&lt;</code> языка Lua.

  <p>Алгоритм сортировки <em>неустойчив</em> (то есть элементы, рассматриваемые как равные, могут изменить свои относительные позиции после сортировки). <a name="pdf-tag"></a> <a name="tag"></a></p>

  <h3><tt>tag (v)</tt></h3>Позволяет программам Lua проверять тэг значения. Это получает один параметр и возвращает тэг (число). <a name="tonumber"></a>

  <h3><tt>tonumber (e [, base])</tt></h3>Пробует преобразовывать параметр в число. Если параметр уже число или строка, обратимая в число, то <code>tonumber</code> вернет это число, иначе это всегда возвращает <b>nil</b>.

  <p>Факультативный параметр определяет ядро, чтобы интерпретировать цифру. Ядром может быть любое целое число между 2 и 36 включительно. В базах более, чем 10, символ A (заглавные или строчные буквы) представляет 10, B соответствует 11 и так далее до символа Z, соответствующему 35. В ядре 10 (значение по умолчанию) число может иметь десятичную часть, также как и факультативную часть экспоненты. В других базах только целые числа без знака. <a name="tostring"></a></p>

  <h3><tt>tostring (e)</tt></h3>Получает параметр любого типа и преобразовывает его в строку в приемлемом формате. Для полного управления тем, как числа будут преобразованы, используйте функцию <code>format</code>. <a name="tinsert"></a>

  <h3><tt>tinsert (table [, pos] , value)</tt></h3>

  <p>Вставляет значение элемента <code>value</code> в позицию <code>pos</code> таблицы, сдвигая другие элементы в случае необходимости на открытое место. Значение по умолчанию для <code>pos</code> равно <code>n+1</code>, где <code>n</code> является результатом <code>getn(table)</code> так, чтобы обращение <code>tinsert(t,x)</code> вставило <code>x</code> в конец таблицы <code>t</code>. Эта функция также устанавливает или увеличивает поле <code>n</code> таблицы, превращая его в <code>n+1</code>. Эта функция эквивалентна следующей функции Lua, за исключением того, что доступ к таблице прямой (без методов тэгов):</p>
  <pre>
function tinsert (t, ...)
  local pos, value
  local n = getn(t)
  if arg.n == 1 then pos, value = n+1, arg[1]
  else pos, value = arg[1], arg[2]
  end
  t.n = n+1;
  for i=n,pos,-1 do
    t[i+1] = t[i]
  end
  t[pos] = value
end
</pre><a name="tremove"></a>

  <h3><tt>tremove (table [, pos])</tt></h3>

  <p>Удаляет из таблицы <code>table</code> элемент в позиции <code>pos</code>, сдвигая в случае необходимости другие элементы, чтобы закрыть образовавшуюся дырку. Возвращает значение удаленного элемента. Значение по умолчанию для <code>pos</code> равно <code>n</code>, где <code>n</code> является результатом <code>getn(table)</code>, чтобы обращение <code>tremove(t)</code> удалило последний элемент из таблицы <code>t</code>. Эта функция также устанавливает поле <code>n</code> таблицы в значение <code>n-1</code>.</p>

  <p>Эта функция эквивалентна следующей функции Lua, за исключением того, что доступ к таблице прямой (без использования методов тэгов):</p>
  <pre>
function tremove (t, pos)
  local n = getn(t)
  if n&lt;=0 then
     return
  end
  pos = pos or n
  local value = t[pos]
  for i=pos,n-1 do
    t[i] = t[i+1]
  end
  t[n] = nil
  t.n = n-1
  return value
end
</pre><a name="pdf-type"></a> <a name="type"></a>

  <h3><tt>type (v)</tt></h3>Позволяет программам Lua проверять тип значения. Это получает один параметр, а возвращает тип, кодированный как строка. Возможные результаты этой функции: <code>&quot;nil&quot;</code> (строка, а не значение <b>nil</b>!), <code>&quot;number&quot;</code>, <code>&quot;string&quot;</code>, <code>&quot;table&quot;</code>, <code>&quot;function&quot;</code> и <code>&quot;userdata&quot;</code>. 

  <h2>6.2 Строковые манипуляции в Lua</h2>Эта библиотека обеспечивает универсальные функции для манипулирования строками, типа нахождения и извлечения соответствия образца и подстрок. При индексации строки в Lua, первый символ находится в позиции 1 (не в 0, как в C!). Также, индексам позволено быть отрицательными, что понимается как индексация в обратном направлении, с конца строка к началу. Таким образом, последний символ находится в позиции <i>-1</i> и так далее. <a name="strbyte"></a>

  <h3><tt>strbyte (s [, i])</tt></h3>Возвращает внутренний числовой код <em>i</em>-го символа строки <code>s</code>. Если <code>i</code> отсутствует, то принято 1. <code>i</code> может быть отрицателен.

  <p>Числовые коды не обязательно переносимы между платформами. <a name="strchar"></a></p>

  <h3><tt>strchar (i1, i2, ...)</tt></h3>Получает 0 или большее количество целых чисел. Возвращает строку с длиной, равной числу параметров, в которой каждый символ имеет внутренний числовой код, заданный соответствующим параметром.

  <p>Числовые коды не обязательно переносимы между платформами.</p>

  <h3><tt>strfind (s, pattern [, init [, plain]])</tt></h3><a name="strfind"></a>Ищет первое соответствие образцу <code>pattern</code> в <code>s</code>. Если это найдено, <code>strfind</code> вернет индексы <code>s</code>, где эти вхождения начинаются и заканчивается, иначе это возвращает <b>nil</b>. Если образец определяет набор данных (подробности в описании <code>gsub</code> ниже), зафиксированные строки возвращены как дополнительные результаты. Факультативный числовой параметр <code>init</code> определяет, где запустить поиск: значение по умолчанию 1, и оно может быть отрицательным. Четвертый факультативный аргумент <code>plain</code> выключает средства поиска образца, так что функция просто ищет подстроку без символов в <code>pattern</code>, обрабатываемых особым образом. Обратите внимание, что если задана опция <code>plain</code>, должна быть задана и <code>init</code>. <a name="strlen"></a>

  <h3><tt>strlen (s)</tt></h3>Получает строку и возвращает ее длину. Пустая строка (<code>&quot;&quot;</code>) имеет длину 0. Вложенные ноли в строке считаются, так что строка <code>&quot;a\000b\000c&quot;</code> имеет длину 5 символов. <a name="strlower"></a>

  <h3><tt>strlower (s)</tt></h3>Получает строку и возвращает ее копию со всеми символами верхнего регистра, измененными на строчные буквы. Все другие символы оставлены прежними. Определение того, какие буквы прописные, зависит от настроек региона. <a name="strrep"></a>

  <h3><tt>strrep (s, n)</tt></h3>Возвращает строку, которая является суммой <code>n</code> копий строки <code>s</code>. <a name="strsub"></a>

  <h3><tt>strsub (s, i [, j])</tt></h3>Возвращает другую строку, которая является подстрокой <code>s</code>, начинающегося в <code>i</code> и продолжающейся до <code>j</code>. <code>i</code> и <code>j</code> могут быть отрицательными, Если <code>j</code> отсутствует, то оно считается равным <i>-1</i> (длине строки). В частности, обращение <code>strsub(s,1,j)</code> возвращает префикс <code>s</code> длиной <code>j</code>, а вызов <code>strsub(s, -i)</code> вернет суффикс <code>s</code> длиной <code>i</code>. <a name="strupper"></a>

  <h3><tt>strupper (s)</tt></h3>Получает строку и возвращает копию со всеми символами строчных букв, измененными на верхний регистр. Все другие символы оставлены как есть. Что такое строчные буквы, читается из настроек региона. <a name="format"></a>

  <h3><tt>format (formatstring, e1, e2, ...)</tt></h3><a name="format"></a>Возвращает форматированную версию переменного числа параметров после применения описания, заданного в первом параметре (который должен быть строкой). Строка формата следует тем же самым правилам, что и семейство стандартных функций <code>printf</code> в C. Единственное различие состоит в том, что параметры <code>*</code>, <code>l</code>, <code>L</code>, <code>n</code>, <code>p</code> и <code>h</code> тут не работают, зато имеется дополнительная опция <code>q</code>. Опция <code>q</code> форматирует строку в форме, подходящей, чтобы безопасно читаться обратно Lua интерпретатором. Строка записана между двойными кавычками, а все двойные кавычки и спецсимволы будут правильно экранированы при записи. Например, обращение
  <pre>
format(&#39;%q&#39;, &#39;a string with &quot;quotes&quot; and \n new line&#39;)
</pre>произведет такую строку:
  <pre>
&quot;a string with \&quot;quotes\&quot; and \
 new line&quot;
</pre>

  <p>Преобразования могут применяться к энному параметру в списке параметров вместо следующего неиспользуемого параметра. В этом случае символ <code>%</code> заменен последовательностью <code>%d$</code>, где <code>d</code> десятичная цифра в диапазоне [1,9], определяет позицию параметра в списке. Например, обращение <code>format(&quot;%2$d -&gt; %1$03d&quot;, 1, 34)</code> выдаст результат <code>&quot;34 -&gt; 001&quot;</code>. Тот же самый параметр может использоваться больше, чем в одном преобразовании.</p>

  <p>Опции <code>c</code>, <code>d</code>, <code>E</code>, <code>e</code>, <code>f</code>, <code>g</code>, <code>G</code>, <code>i</code>, <code>o</code>, <code>u</code>, <code>X</code> и <code>x</code> все ожидают число как параметр, в то время как <code>q</code> и <code>s</code> ожидают строку. Модификатор <code>*</code> может применяться, формируя соответствующую строку формата. Например, <code>&quot;%*g&quot;</code> может соответствовать <code>&quot;%&quot;...что-то-внутри...&quot;g&quot;</code>.</p>

  <p>Ни строка формата, ни значения строки, которые нужно форматировать с <code>%s</code>, не могут содержать вложенные ноли. Но <code>%q</code> обрабатывает значения строк с вложенными нолями. <a name="gsub"></a></p>

  <h3><tt>gsub (s, pat, repl [, n])</tt></h3>Возвращает копию <code>s</code>, в которой все местонахождения образца <code>pat</code> были заменены строкой замены, определенной в <code>repl</code>. Функция <code>gsub</code> также возвращает, как второе значение, общее количество сделанных замен.

  <p>Если <code>repl</code> является строкой, то значение используется для замены как есть. Любая последовательность в <code>repl</code> в форме <code>%n</code> с <code>n</code> от 1 до 9 предназначена для <em>n</em>-й зафиксированной подстроки.</p>

  <p>Если <code>repl</code> представляет собой функцию, то эта функция будет вызвана каждый раз, когда соответствие происходит, со всеми зафиксированными подстроками, переданными как параметры. Если значение, возвращенное этой функцией, является строкой, то это используется как строка для замены, иначе берется пустая строка.</p>

  <p>Последний факультативный параметр <code>n</code> ограничивает максимальное число замен. Например, когда <code>n</code> равно 1, только первое местонахождение <code>pat</code> будет обработано.</p>

  <p>Имеются некоторые примеры:</p>
  <pre>
   x = gsub(&quot;hello world&quot;, &quot;(%w+)&quot;, &quot;%1 %1&quot;)
   --&gt; x=&quot;hello hello world world&quot;
   x = gsub(&quot;hello world&quot;, &quot;(%w+)&quot;, &quot;%1 %1&quot;, 1)
   --&gt; x=&quot;hello hello world&quot;
   x = gsub(&quot;hello world from Lua&quot;, &quot;(%w+)%s*(%w+)&quot;, &quot;%2 %1&quot;)
   --&gt; x=&quot;world hello Lua from&quot;
   x = gsub(&quot;home = $HOME, user = $USER&quot;, &quot;%$(%w+)&quot;, getenv)
   --&gt; x=&quot;home = /home/roberto, user = roberto&quot;  (for instance)
   x = gsub(&quot;4+5 = $return 4+5$&quot;, &quot;%$(.-)%$&quot;, dostring)
   --&gt; x=&quot;4+5 = 9&quot;
   local t = {name=&quot;lua&quot;, version=&quot;4.0&quot;}
   x = gsub(&quot;$name - $version&quot;, &quot;%$(%w+)&quot;, function (v) return %t[v] end)
   --&gt; x=&quot;lua - 0&quot;
   t = {n=0}
   gsub(&quot;first second word&quot;, &quot;(%w+)&quot;, function (w) tinsert(%t, w) end)
   --&gt; t={&quot;first&quot;, &quot;second&quot;, &quot;word&quot;; n=3}
</pre><a name="pm"></a>

  <h3>Шаблоны</h3>

  <h4>Символьный класс:</h4><a name="character class"><em>Символьный класс</em></a> используется, чтобы представить набор символов. Следующие комбинации позволяются в описании символьного класса:

  <dl>
    <dt><b><em>x</em></b></dt>

    <dd>Здесь <em>x</em> любые волшебные символы: <code>^$()%.[]*+-?</code>. Представляет непосредственно символ <em>x</em>.</dd>

    <dt><b><tt>. (точка)</tt></b></dt>

    <dd>Представляет все символы.</dd>

    <dt><b><tt>%a</tt></b></dt>

    <dd>Представляет все буквы.</dd>

    <dt><b><tt>%c</tt></b></dt>

    <dd>Представляет все спецсимволы.</dd>

    <dt><b><tt>%d</tt></b></dt>

    <dd>Представляет все цифры.</dd>

    <dt><b><tt>%l</tt></b></dt>

    <dd>Представляет все буквы в нижнем регистре.</dd>

    <dt><b><tt>%p</tt></b></dt>

    <dd>Представляет все символы пунктуации.</dd>

    <dt><b><tt>%s</tt></b></dt>

    <dd>Представляет все пробелы.</dd>

    <dt><b><tt>%u</tt></b></dt>

    <dd>Представляет все буквы в верхнем регистре.</dd>

    <dt><b><tt>%w</tt></b></dt>

    <dd>Представляет все алфавитно-цифровые символы.</dd>

    <dt><b><tt>%x</tt></b></dt>

    <dd>Представляет все шестнадцатеричные цифры.</dd>

    <dt><b><tt>%z</tt></b></dt>

    <dd>Представляет символ с представлением 0.</dd>

    <dt><b><tt>%<em>x</em></tt></b></dt>

    <dd>Здесь <em>x</em> задает любой не алфавитно-цифровой символ. Представляет символ <em>x</em>. Это стандартный способ экранировки управляющих спецсимволов. Лучше следить за тем, чтобы любому символу пунктуации (даже не управляющему!) предшествовал <code>%</code>, когда символ применен в образце.</dd>

    <dt><b><tt>[char-set</tt></b>]</dt>

    <dd>Представляет класс, который является объединением всех символов в <code>char-set</code>. Диапазон символов может быть определен, отделяя конечные символы диапазона тире (<code>-</code>). Все классы <code>%</code><em>x</em>, описанные выше, могут также использоваться как компоненты в char-set. Все другие символы в char-set представляются как есть. Например, <code>[%w_]</code> (или <code>[_%w]</code>) представляет все алфавитно-цифровые символы плюс символ подчеркивания, <code>[0-7]</code> представляет восьмеричные цифры, а <code>[0-7%l%-]</code> представляет восьмеричные цифры плюс символы строчных букв плюс символ тире. Взаимодействие между диапазонами и классами не определено. Следовательно, образцы, подобные <code>[%a-z]</code> или <code>[a-%%]</code> не имеют никакого значения.</dd>

    <dt><b><tt>[^char-set</tt></b>]</dt>

    <dd>Представляет дополнение <code>char-set</code>, где <code>char-set</code> интерпретируется как выше.</dd>
  </dl>

  <p>Для всех классов, представляемых одиночными символами (<code>%a</code>, <code>%c</code>, ...), соответствующая прописная буква представляет дополнение класса. Например, <code>%S</code> представляет все не пробелы.</p>

  <p>Определения символа, пробела и т.д. зависят от текущего региона. В частности, класс <code>[a-z]</code> не может быть эквивалентен <code>%l</code>. Вторая форма должна быть предпочтительней для переносимости.</p>

  <h4>Элемент образца:</h4><a name="pattern item"><em>Элементом образца</em></a> может быть:

  <ul>
    <li>Одиночный символьный класс, который соответствует любому одиночному символу в классе.</li>

    <li>Одиночный символьный класс, сопровождаемый <code>*</code>, что соответствует 0 или большему количеству повторений символов в классе. Эти элементы повторения будут всегда соответствовать самой длинной возможной последовательности.</li>

    <li>Одиночный символьный класс, сопровождаемый <code>+</code>, что соответствует 1 или большему количеству повторений символов в классе. Эти элементы повторения будут всегда соответствовать самой длинной возможной последовательности.</li>

    <li>Одиночный символьный класс, сопровождаемый <code>-</code>, что также соответствует 0 или большему количеству повторений символов в классе. В отличие от <code>*</code>, элементы повторения будут всегда соответствовать самой короткой возможной последовательности.</li>

    <li>Одиночный символьный класс, сопровождаемый <code>?</code>, что соответствует 0 или 1 местонахождению символа в классе.</li>

    <li><tt>%<em>n</em></tt>, для <em>n</em> от 1 до 9. Такой элемент соответствует подстроке, равной <em>n</em>-й зафиксированной строке.</li>

    <li><tt>%b<em>xy</em></tt>, здесь <em>x</em> и <em>y</em> два различных символа. Такой элемент соответствует строкам, которые начинаются с <em>x</em>, заканчиваются на <em>y</em>, и в них <em>сбалансированы</em> <em>x</em> и <em>y</em>. Это означает, что, если читать строку слева направо, подсчитывая <i>+1</i> для <em>x</em> и <i>-1</i> для <em>y</em>, то последний <em>y</em> является первым <em>y</em>, для которого счетчик равен 0. Например, элемент <code>%b()</code> соответствует выражениям со сбалансированными круглыми скобками.</li>
  </ul>

  <h4>Шаблоны:</h4><a name="pattern"><em>Шаблон</em></a> представляет собой последовательность элементов образца. Циркумфлекс (<code>^</code>) в начале образца закрепляет соответствие в начале подчиненной строки. <code>$</code> в конце образца закрепляет соответствие в конце подчиненной строки. В других позициях <code>^</code> и <code>$</code> не имеют никакого специального значения и представляются как есть.

  <h4>Сборы данных:</h4>Образец может содержать подобразцы, включенные в круглые скобки, они описывают <em>сборы данных</em>. Когда соответствие выполнено, подстроки подчиненной строки, которые соответствуют сборам данных, сохранены для будущего использования. Сборы данных пронумерованы согласно их левым круглым скобкам. Например, в образце <code>&quot;(a*(.)%w(%s*))&quot;</code>, часть соответствия строки <code>&quot;a*(.)%w(%s*)&quot;</code> сохранена как первый сбор данных (а, следовательно, имеет номер 1), символьное соответствие <code>.</code> зафиксировано с номером 2, а часть, соответствующая <code>%s*</code>, конечно, имеет номер 3.

  <p>Образец не может содержать вложенные ноли. Используйте вместо этого <code>%z</code>. <a name="mathlib"></a></p>

  <h2>6.3 Математические функции</h2>

  <p>Эта библиотека предоставляет интерфейс к некоторым функциям стандартной математической библиотеки C. Кроме того, это регистрирует метод тэга для двоичного оператора <code>^</code>, который возвращает <i>x^y</i>, когда применяется к числам <code>x^y</code>.</p>

  <p>Библиотека обеспечивает следующие функции: <a name="abs"></a><a name="acos"></a><a name="asin"></a><a name="atan"></a><a name="atan2"></a><a name="ceil"></a><a name="cos"></a><a name="def"></a><a name="exp"></a><a name="floor"></a><a name="log"></a><a name="log10"></a><a name="max"></a><a name="min"></a><a name="mod"></a><a name="rad"></a><a name="sin"></a><a name="sqrt"></a><a name="tan"></a><a name="frexp"></a><a name="ldexp"></a><a name="random"></a><a name="randomseed"></a></p>
  <pre>
abs  acos  asin  atan  atan2  ceil  cos  deg    exp    floor   log  log10
max  min   mod   rad   sin    sqrt  tan  frexp  ldexp  random  randomseed
</pre>Плюс глобальная переменная <a name="PI"><tt>PI</tt></a>. Большинство из них представляют собой только интерфейсы к функциям в C-библиотеке, за исключением того, что для тригонометрических функций все углы выражены в <em>градусах</em>, а не в радианах. Функции <code>deg</code> и <code>rad</code> могут использоваться для того, чтобы преобразовывать данные между радианами и градусами.

  <p>Функция <code>max</code> возвращает максимальное значение числовых параметров. Точно так же <code>min</code> вычисляет минимум. Обе они могут использоваться с 1, 2 или большим количеством параметров.</p>

  <p>Функции <code>random</code> и <code>randomseed</code> представляют собой интерфейсы к простому генератору случайных чисел, предоставляемому ANSI C (соответвенно функции <code>rand</code> и <code>srand</code>). Не может быть дпно никаких гарантий касательно их статистических свойств. Функция <code>random</code> при вызове без параметров возвращает псевдослучайное вещественное число в диапазоне <i>[0,1)</i>. При вызове с параметром <i>n</i>, <code>random</code> вернет псевдослучайное целое число в диапазоне <i>[1,n]</i>. При вызове с двумя параметрами <i>l</i> и <i>u</i>, <code>random</code> вернет псевдослучайное целое число в диапазоне <i>[l,u]</i>. Границы всегда входят в диапазон. <a name="libio"></a></p>

  <h2>6.4 Средства ввода-вывода</h2>

  <p>Все операции ввода-вывода в Lua реализованы через два <a name="file handles"><em>дескриптора файла</em></a>, по одному на ввод и вывод. Эти дескрипторы сохранены в двух глобальных переменных Lua, названных <code>_INPUT</code> и <code>_OUTPUT</code>. Глобальные переменные <code>_STDIN</code>, <code>_STDOUT</code> и <code>_STDERR</code> инициализированы с описателями файлов для <code>stdin</code>, <code>stdout</code> и <code>stderr</code>. Первоначально Initially, <code>_INPUT=_STDIN</code> и <code>_OUTPUT=_STDOUT</code>. <a name="_INPUT"></a><a name="_OUTPUT"></a><a name="_STDIN"></a><a name="_STDOUT"></a><a name="_STDERR"></a></p>

  <p>Дескриптор файла представляет собой объект userdata, содержащий поток файла (<code>FILE*</code>) с отличительным тэгом, созданным библиотекой ввода-вывода (I/O).</p>

  <p>Если иное не установлено, все функции I/O возвращают <b>nil</b> на сбое и некоторое значение, отличное от <b>nil</b>, при успехе. <a name="openfile"></a></p>

  <h3><tt>openfile (filename, mode)</tt></h3>

  <p>Эта функция открывает файл в режиме, определенном в строке <code>mode</code>. Это возвращает новый дескриптор файла или, в случае ошибок, <b>nil</b> плюс строку, описывающую ошибку. Эта функция не изменяет <code>_INPUT</code> или <code>_OUTPUT</code>.</p>

  <p>Строка <code>mode</code> может быть любой из следующего списка:</p>

  <dl>
    <dt><b>r</b></dt>

    <dd>Режим чтения.</dd>

    <dt><b>w</b></dt>

    <dd>Режим записи.</dd>

    <dt><b>a</b></dt>

    <dd>Режим добавления к концу.</dd>

    <dt><b>r+</b></dt>

    <dd>Режим обновления, все ранее записанные данные сохраняются.</dd>

    <dt><b>w+</b></dt>

    <dd>Режим обновления, все ранее записанные данные уничтожаются.</dd>

    <dt><b>a+</b></dt>

    <dd>Режим модификации, предыдущие данные сохраняются, запись позволяется только в конце файла.</dd>
  </dl>Строка <code>mode</code> может также иметь в конце <code>b</code>, что необходимо в некоторых системах, чтобы открыть файл в двоичном режиме. Эта строка аналогична той, что используется в стандартной функции C <code>fopen</code>. <a name="closefile"></a>

  <h3><tt>closefile (handle)</tt></h3>

  <p>Эта функция закрывает файл. Это не изменяет <code>_INPUT</code> или <code>_OUTPUT</code>. <a name="readfrom"></a></p>

  <h3><tt>readfrom (filename)</tt></h3>

  <p>Эта функция может быть вызвана двумя путями. Когда она вызвана с именем файла, открывает именованный файл, устанавливает дескриптор как значение <code>_INPUT</code> и возвращает это значение. Это не закрывает текущий файл input. При вызове без параметров, она закрывает файл <code>_INPUT</code> и восстанавливает <code>stdin</code> как значение <code>_INPUT</code>. Если эта функция где-то не сработала, она возвращает <b>nil</b> плюс строку описания.</p>

  <p>Если <code>filename</code> начинается с символа трубопровода <code>|</code>, открывается поточный ввод <a name="piped input"></a>через функцию <a name="popen"><tt>popen</tt></a>. Не все системы его выполняют. Кроме того, число файлов, которые могут быть открыты в то же самое время, обычно ограничивается и зависит от системы. <a name="writeto"></a></p>

  <h3><tt>writeto (filename)</tt></h3>

  <p>Эта функция может быть вызвана двумя путями. Когда она вызвана с именем файла, открывает именованный файл, устанавливает дескриптор как значение <code>_OUTPUT</code> и возвращает это значение. Это не закрывает текущий выходной файл. Обратите внимание, что если файл уже существует, <em>то он будет полностью уничтожен</em> этой операцией. Когда функция вызвана без параметров, она закрывает файл <code>_OUTPUT</code> и восстанавливает <code>stdout</code> как значение <code>_OUTPUT</code>. В случае ошибки функция возвращает <b>nil</b> плюс строку, описывающую ошибку. <a name="closing a file"></a></p>

  <p>Если <code>filename</code> начинается с символа трубопровода <code>|</code>, открывается поточный ввод <a name="piped input"></a>через функцию <a name="popen"><tt>popen</tt></a>. Не все системы его выполняют. Кроме того, число файлов, которые могут быть открыты в то же самое время, обычно ограничивается и зависит от системы. <a name="appendto"></a></p>

  <h3><tt>appendto (filename)</tt></h3>

  <p>Открывает файл, именованный <code>filename</code> и устанавливает это как значение <code>_OUTPUT</code>. В отличие от операции <code>writeto</code>, эта функция не стирает предыдущее содержание файла, вместо этого все, что пишется в файл, будет конкатенировано к концу. Если эта функция получила сбой, она вернет <b>nil</b> плюс строку, описывающую ошибку. <a name="remove"></a></p>

  <h3><tt>remove (filename)</tt></h3>

  <p>Удаляет файл с данным именем. Если эта функция получила сбой, она вернет <b>nil</b> плюс строку с описанием ошибки. <a name="rename"></a></p>

  <h3><tt>rename (name1, name2)</tt></h3>

  <p>Переименовывает файл <code>name1</code> в <code>name2</code>. Если эта функция получила сбой, она вернет <b>nil</b> плюс строку с описанием ошибки. <a name="flush"></a></p>

  <h3><tt>flush ([filehandle])</tt></h3>

  <p>Сохраняет любые записанные данные в заданный файл. Если <code>filehandle</code> не определен, то <code>flush</code> сбросит на диск все открытые файлы. Если эта функция получила сбой, она вернет <b>nil</b> плюс строку с описанием ошибки. <a name="seek"></a></p>

  <h3><tt>seek (filehandle [, whence] [, offset])</tt></h3>

  <p>Получает позицию файла, измеряемую в байтах от начала файла, и меняет ее на позицию, данную смещением <code>offset</code> плюс ядром, определенным как строка <code>whence</code> следующим образом:</p>

  <dl>
    <dt><b>set</b></dt>

    <dd>Позиция 0 (начало файла).</dd>

    <dt><b>cur</b></dt>

    <dd>Текущая позиция.</dd>

    <dt><b>end</b></dt>

    <dd>Конец файла.</dd>
  </dl>В случае успеха функция <code>seek</code> возвращает конечную позицию файла, измеряемую в байтах от начала файла. Если эта функция получила сбой, она вернет <b>nil</b> плюс строку, описывающую эту ошибку.

  <p>Значение по умолчанию для <code>whence</code> равно <code>cur</code>, а для <code>offset</code> это 0. Следовательно, вызов <code>seek(file)</code> возвращает текущую позицию файла без того, чтобы изменить это. Вызов <code>seek(file, &quot;set&quot;)</code> устанавливает позицию на начало файла (и возвращает 0), а <code>seek(file, &quot;end&quot;)</code> устанавливает позицию в конец файла и возвращает его размер. <a name="tmpname"></a></p>

  <h3><tt>tmpname ()</tt></h3>

  <p>Возвращает строку с именем файла, которое может безопасно использоваться для временного файла. Файл должен быть явно открыт перед использованием и удален, когда больше не нужен. <a name="read"></a></p>

  <h3><tt>read ([filehandle,] format1, ...)</tt></h3>

  <p>Читает файл <code>_INPUT</code> или <code>filehandle</code>, если этот параметр задан, согласно данным форматам, которые определяют, что читать. Для каждого формата, функция возвращает строку или число с прочитанными данными или <b>nil</b>, если не может читать данные с определенным форматом. Когда вызвана без форматов, эта функция использует заданный по умолчанию формат, который читает следующую строку.</p>

  <p>Доступные форматы такие:</p>

  <dl>
    <dt><b>*n</b></dt>

    <dd>Читает число. Это единственный формат, который возвращает число вместо строки.</dd>

    <dt><b>*l</b></dt>

    <dd>Читает следующую строку (обходя концы строк) или <b>nil</b> в конце файла. Это и есть заданный по умолчанию формат.</dd>

    <dt><b>*a</b></dt>

    <dd>Читает целый файл, начинающийся в текущей позиции. На конце файла, возвращает пустую строку.</dd>

    <dt><b>*w</b></dt>

    <dd>Читает следующее слово (максимальная последовательность символов без пробелов. Пробелы обходит в случае необходимости. Замечу, что под пробелом здесь понимается не только собственно пробел, но и спецсимволы. В конце файла функция вернет <b>nil</b>.</dd>

    <dt><b><em>Число</em></b></dt>

    <dd>Читает строку до указанного числа символов в длину или <b>nil</b> на конце файла.</dd>
  </dl><a name="write"></a>

  <h3><tt>write ([filehandle, ] value1, ...)</tt></h3>

  <p>Пишет значение каждого из параметров в файл <code>_OUTPUT</code> или в <code>filehandle</code>, если этот параметр задан. Параметры должны быть строками или числами. Чтобы писать другие значения, используйте <code>tostring</code> или <code>format</code> перед <code>write</code>. Если эта функция нарвалась на ошибку, она вернет <b>nil</b> и строку с описанием данной ошибки. <a name="libiosys"></a></p>

  <h2>6.5 Средства системы</h2><a name="clock"></a>

  <h3><tt>clock ()</tt></h3>

  <p>Возвращает приближение количество времени CPU, используемое программой (в секундах). <a name="date"></a></p>

  <h3><tt>date ([format])</tt></h3>

  <p>Возвращает строку, содержащую дату и время, форматируемую согласно данному формату <code>format</code>. Формат задается по тем же самым правилам, что и в функции ANSI C <code>strftime</code>. Когда вызвана без параметров, возвращает приемлемое представление даты и времени, которое зависит от ведущей системы и от текущего региона. <a name="execute"></a></p>

  <h3><tt>execute (command)</tt></h3>

  <p>Эта функция эквивалентна функции C <code>system</code>. Это передает команду <code>command</code>, которая будет выполнена оболочкой операционной системы. Возвращает код состояния, который является зависимым от системы. <a name="exit"></a></p>

  <h3><tt>exit ([code])</tt></h3>

  <p>Вызывает C-функцию <code>exit</code> с факультативным кодом завершения программы <code>code</code>. Значение по умолчанию для <code>code</code>: код успешного завершения. <a name="getenv"></a></p>

  <h3><tt>getenv (varname)</tt></h3>

  <p>Возвращает значение системной переменной процесса <code>varname</code> или <b>nil</b>, если эта переменная не определена. <a name="setlocale"></a></p>

  <h3><tt>setlocale (locale [, category])</tt></h3>

  <p>Эта функция предоставляет интерфейс к функции ANSI C <code>setlocale</code>. <code>locale</code> представляет собой строку, определяющую регион, <code>category</code> факультативная строка, описывающая которую категорию изменить: <code>&quot;all&quot;</code>, <code>&quot;collate&quot;</code>, <code>&quot;ctype&quot;</code>, <code>&quot;monetary&quot;</code>, <code>&quot;numeric&quot;</code> или <code>&quot;time&quot;</code>, заданная по умолчанию категория: <code>&quot;all&quot;</code>. Функция возвращает имя нового региона или <b>nil</b>, если этот запрос не может быть выполнен. <a name="debugI"></a></p>

  <h1>7 Интерфейс отладки</h1>

  <p>Lua не имеет никаких встроенных средств отладки. Вместо этого, это предлагает специальный интерфейс, посредством функций и обработчиков прерываний, который позволяет создание различных видов отладчиков, профилировщиков и других инструментальных средств, которые нуждаются во <em>внутренней информации из интерпретатора</em>. Этот интерфейс объявлен в файле заголовков <code>luadebug.h</code>. </p>

  <h2>7.1 Информация стека и функций</h2>

  <p><a name="lua_getstack"></a>Основная функция, чтобы получить информацию относительно стека интерпретатора:</p>
  <pre>
int lua_getstack (lua_State *L, int level, lua_Debug *ar);
</pre>Это заполняет части структуры <code>lua_Debug</code> с идентификацией <em>записи активации</em> функции, выполняющейся в заданном уровне. Уровень 0 текущая функция управления, в то время как уровень <i>n+1</i> функция, которая вызвала уровнем <i>n</i>. Обычно <code>lua_getstack</code> вернет 1, когда вызвана с уровнем больше, чем глубина стека, она возвращает 0.

  <p><a name="lua_Debug"></a>Структура <code>lua_Debug</code> используется, чтобы нести различные части информации относительно активной функции:</p>
  <pre>
typedef struct lua_Debug {
  const char *event;     /* &quot;call&quot;, &quot;return&quot; */
  int currentline;       /* (l) */
  const char *name;      /* (n) */
  const char *namewhat;
          /* (n) поля, глобальные и локальные переменные, методы тэгов */
  int nups;              /* (u) количество upvalues */
  int linedefined;       /* (S) */
  const char *what;      /* (S) &quot;Lua&quot; функция, &quot;C&quot; функция, Lua &quot;main&quot; */
  const char *source;    /* (S) */
  char short_src[LUA_IDSIZE]; /* (S) */
  /* private part */
  ...
} lua_Debug;
</pre><code>lua_getstack</code> заполняет только одну из частей этой структуры для будущего использования. Чтобы заполнить другие поля <code>lua_Debug</code> полезной информацией, надо вызвать: <a name="lua_getinfo"></a>
  <pre>
int lua_getinfo (lua_State *L, const char *what, lua_Debug *ar);
</pre>Эта функция возвращает 0 на ошибке (например, недопустимая опция в <code>what</code>). Каждый символ в строке <code>what</code> указывает некоторые поля <code>ar</code>, которые будет заполнены, как обозначено символом в круглых скобках в определении <code>lua_Debug</code>: <code>S</code> заполняет поле исходником (<code>source</code>), <code>linedefined</code> и <code>what</code>, <code>l</code> заполняет поле текущей строкой (<code>currentline</code>) и так далее. Кроме того, <code>f</code> помещает в стек функцию, которая работает в данном уровне.

  <p>Чтобы добираться до информации относительно функции, которая не активна (то есть она не в стеке), Вы помещаете функцию в стек и начинаете строку <code>what</code> с символа <code>&gt;</code>. Например, чтобы знать, в которой строке функция <code>f</code> была определена, Вы можете писать:</p>
  <pre>
  lua_Debug ar;
  lua_getglobal(L, &quot;f&quot;);
  lua_getinfo(L, &quot;&gt;S&quot;, &amp;ar);
  printf(&quot;%d\n&quot;, ar.linedefined);
</pre>Поля <code>lua_Debug</code> имеют следующее значение:

  <dl>
    <dt><b>source</b></dt>

    <dd>Если функция была определена в строке, <code>source</code> как раз и будет этой строкой, а если функция была определена в файле, <code>source</code> начинается с <code>@</code>, а дальше имя файла.</dd>

    <dt><b>short_src</b></dt>

    <dd>Пригодная к печати версия <code>source</code>, чтобы использоваться в сообщениях об ошибке.</dd>

    <dt><b>linedefined</b></dt>

    <dd>Код строки, где было начато определение функции.</dd>

    <dt><b>what</b></dt>

    <dd>Строка <code>&quot;Lua&quot;</code>, если это функция Lua, <code>&quot;C&quot;</code>, если это функция C или <code>&quot;main&quot;</code>, если это основная часть chunk.</dd>

    <dt><b>currentline</b></dt>

    <dd>Текущая строка, где данная функция выполняется. Когда никакая информация о строке недоступна, <code>currentline</code> установлен в <i>-1</i>.</dd>

    <dt><b>name</b></dt>

    <dd>Приемлемое имя для данной функции. Так как функции в Lua значения первого класса, они не имеют фиксированных имен. Именем функции может быть значение многих глобальных переменных, в то время как другие функции могут быть сохранены только в поле таблицы. Функция <code>lua_getinfo</code> проверяет, является ли данная функция методом тэга или значением глобальной переменной. Если данная функция представляет собой метод тэга, <code>name</code> указывает на имя события. Если данная функция является значением глобальной переменной, то <code>name</code> указывает на имя переменной. Если данная функция не является ни методом тэга, ни глобальной переменной, то <code>name</code> установлен в <code>NULL</code>.</dd>

    <dt><b>namewhat</b></dt>

    <dd>Объясняет предыдущее поле. Если функция глобальная переменная, <code>namewhat</code> равен <code>&quot;global&quot;</code>. Если функция метод тэга, <code>namewhat</code> равен <code>&quot;tag-method&quot;</code>, иначе <code>namewhat</code> равен <code>&quot;&quot;</code> (пустой строке).</dd>

    <dt><b>nups</b></dt>

    <dd>Число upvalues в функции.</dd>
  </dl>

  <h2>7.2 Управление локальными переменными</h2>

  <p>Для манипулирования локальными переменными <code>luadebug.h</code> использует индексы: первый параметр или локальная переменная имеет индекс 1 и так далее до последней активной локальной переменной.</p>

  <p><a name="lua_getlocal"></a><a name="lua_setlocal"></a>Следующие функции позволяют манипулировать локальными переменными данной активной записи.</p>
  <pre>
const char *lua_getlocal (lua_State *L, const lua_Debug *ar, int n);
const char *lua_setlocal (lua_State *L, const lua_Debug *ar, int n);
</pre>Параметр <code>ar</code> должен быть имеющей силу записью активации, заполненной предыдущим обращением к <code>lua_getstack</code> или данный как параметр обработчика прерываний. Функция <code>lua_getlocal</code> получает индекс локальной переменной (<code>n</code>), помещает значение в стек и возвращает имя. Для <code>lua_setlocal</code> Вы помещаете новое значение в стек, а функция назначает это значение переменной и возвращает имя. Обе функции возвращают <code>NULL</code> при сбое. Это случается, если заданный индекс больше, чем число активных локальных переменных.

  <p>Как пример, следующая функция вносит в список имена всех локальных переменных функции в данном уровне стека:</p>
  <pre>
int listvars (lua_State *L, int level) {
  lua_Debug ar;
  int i = 1;
  const char *name;

  if (lua_getstack(L, level, &amp;ar) == 0) return 0;
     /* failure: no such level in the stack */
  while ((name = lua_getlocal(L, &amp;ar, i++)) != NULL) {
    printf(&quot;%s\n&quot;, name);
    lua_pop(L, 1);  /* remove variable value */
  }
  return 1;
}
</pre><a name="sub-hooks"></a>

  <h2>7.3 Обработчики прерываний</h2>

  <p>Lua-интерпретатор предлагает два обработчика прерываний для целей отладки: <em>call</em> и <em>line</em>. Оба обработчика имеют тот же самый тип: <a name="lua_Hook"></a></p>
  <pre>
typedef void (*lua_Hook) (lua_State *L, lua_Debug *ar);
</pre>Вы можете устанавливать их со следующими функциями: <a name="lua_setcallhook"></a><a name="lua_setlinehook"></a>
  <pre>
lua_Hook lua_setcallhook (lua_State *L, lua_Hook func);
lua_Hook lua_setlinehook (lua_State *L, lua_Hook func);
</pre>Обработчик прерываний заблокирован, когда значение <code>NULL</code>, что и является начальным значением обоих обработчиков прерываний. Функции <code>lua_setcallhook</code> и <code>lua_setlinehook</code> устанавливают соответствующие обработчики прерываний и возвращают их предыдущие значения.

  <p>Обработчик прерываний call вызван всякий раз, когда интерпретатор вызывает или оставляет функцию. Поле события <code>event</code> записи <code>ar</code> имеет строки <code>&quot;call&quot;</code> или <code>&quot;return&quot;</code>. Этот <code>ar</code> может затем использоваться в обращениях для <code>lua_getinfo</code>, <code>lua_getlocal</code> и <code>lua_setlocal</code>, чтобы получить большее количество информации относительно функции и управлять локальными переменными.</p>

  <p>Обработчик прерываний line вызван каждый раз, когда интерпретатор изменяет строку кода, которую выполняет. Поле <code>event</code> в <code>ar</code> имеет строку <code>&quot;line&quot;</code>, а поле <code>currentline</code> хранит код строки. Вы можете использовать этот <code>ar</code> в других обращениях к отладочному API.</p>

  <p>В то время как Lua управляет обработчиком прерываний, это отключает другие обращения к обработчикам прерываний. Следовательно, если обработчик прерываний вызывает Lua, чтобы выполнить функцию или chunk, это выполнение идет без обращений к обработчикам прерываний. </p>

  <h2>7.4 Рефлексивный интерфейс отладки</h2>

  <p>Библиотека <code>ldblib</code> обеспечивает функциональные возможности интерфейса отладки программам Lua. Если Вы хотите использовать эту библиотеку, Ваша ведущая прикладная программа должна открыть ее вызовом <code>lua_dblibopen</code>.<a name="lua_dblibopen"></a></p>

  <p>Вы должны проявить большую осторожность при использовании этой библиотеки. Функции, обеспеченные здесь, должны использоваться исключительно для отладки и подобных задач (например, профилирования). Пожалуйста, сопротивляйтесь искушению использовать их как обычный инструмент программирования. Они медленны и нарушают некоторые аспекты языка (например, секретность локальных переменных). Как общее правило, если Ваша программа не нуждается в этой библиотеке, не открывайте ее вообще. <a name="getinfo"></a></p>

  <h3><tt>getinfo (function, [what])</tt></h3>

  <p>Эта функция возвращает таблицу с информацией относительно функции. Вы можете давать функцию непосредственно, или Вы можете давать число как значение <code>function</code>, что означает функциональное управление в уровне стека <code>function</code>. Уровень 0 считается текущей функцией (непосредственно <code>getinfo</code>), уровень 1: функция, которая вызвала <code>getinfo</code> и так далее. Если <code>function</code> представляет собой число большее, чем число активных функций, то <code>getinfo</code> сразу вернет <b>nil</b>.</p>

  <p>Возвращенная таблица содержит все поля, возвращенные <code>lua_getinfo</code> со строкой <code>what</code> описывающий, что нужно получить. Значение по умолчанию для <code>what</code>: нужно получить всю доступную информацию.</p>

  <p>Например, выражение <code>getinfo(1,&quot;n&quot;).name</code> вернет имя текущей функции, если приемлемое имя может быть найдено, и <code>getinfo(print)</code> возвращает таблицу со всей доступной информацией относительно функции <code>print</code>. <a name="getlocal"></a></p>

  <h3><tt>getlocal (level, local)</tt></h3>

  <p>Эта функция возвращает имя и значение локальной переменной с индексом, <code>local</code> на уровне <code>level</code> стека. Первый параметр или локальная переменная имеет индекс 1 и так далее до последней активной локальной переменной. Функция вернет <b>nil</b>, если не имеется никакой локальной переменной с данным индексом, и поднимает ошибку когда вызвана с <code>level</code> вне диапазона. Вы можете вызывать <code>getinfo</code>, чтобы проверить, имеет ли этот уровень силу. <a name="setlocal"></a></p>

  <h3><tt>setlocal (level, local, value)</tt></h3>

  <p>Эта функция назначает значение <code>value</code> локальной переменной с индексом <code>local</code> функции на уровне <code>level</code> стека. Функция вернет <b>nil</b>, если не имеется никакой локальной переменной с данным индексом, и поднимает ошибку когда вызвана с уровнем <code>level</code> вне диапазона. <a name="setcallhook"></a></p>

  <h3><tt>setcallhook (hook)</tt></h3>

  <p>Устанавливает функциональный обработчик прерываний <code>hook</code> как обработчик прерываний call. Этот обработчик прерываний будет вызван каждый раз при начале и завершении интерпретации функции. Единственный параметр на обработчик прерываний call: имя события (<code>&quot;call&quot;</code> или <code>&quot;return&quot;</code>). Вы можете вызывать <code>getinfo</code> с уровнем 2, чтобы получить большее количество информации относительно функции (уровень 0 соответствует функции <code>getinfo</code>, а уровень 1 задает функцию обработчика прерываний. Когда вызвана без параметров, эта функция выключает обработчики прерываний call. <code>setcallhook</code> вернет старый обработчик прерываний. <a name="setlinehook"></a></p>

  <h3><tt>setlinehook (hook)</tt></h3>

  <p>Устанавливает функциональный обработчик прерываний <code>hook</code> как обработчик прерываний line. Этот обработчик прерываний будет вызван каждый раз, когда интерпретатор изменяет обрабатываемую строку кода. Единственный параметр на обработчике прерываний line: код строки, которую интерпретатор собирается выполнять. Когда вызвана без параметров, эта функция выключает обработчики прерываний line. Вызов <code>setlinehook</code> возвращает старый обработчик прерываний. <a name="lua-sa"></a></p>

  <h1>8 Lua в автономном режиме</h1>

  <p>Хотя Lua был разработан как язык расширений, чтобы быть вложенным в ведущую программу на C, это часто используется как автономный язык. Интерпретатор для Lua, как автономного языка, называется просто <code>lua</code>. Эта программа может быть вызвана с любой последовательностью следующих параметров:</p>

  <dl>
    <dt><b><tt>-sNUM</tt></b></dt>

    <dd>Устанавливает размер стека в <tt>NUM</tt> (если используется, должно быть первой опцией).</dd>

    <dt><b><tt>-</tt></b></dt>

    <dd>Выполняет <code>stdin</code> как файл.</dd>

    <dt><b><tt>-c</tt></b></dt>

    <dd>Вызывает <code>lua_close</code> после обработки всех параметров.</dd>

    <dt><b><tt>-e</tt> \rm<em>stat</em></b></dt>

    <dd>Выполняет строку <code>stat</code>.</dd>

    <dt><b><tt>-f filename</tt></b></dt>

    <dd>Выполняет файл <code>filename</code> с параметрами для таблицы <code>arg</code>.</dd>

    <dt><b><tt>-i</tt></b></dt>

    <dd>Вводит интерактивный режим с подсказкой.</dd>

    <dt><b><tt>-q</tt></b></dt>

    <dd>Вводит интерактивный режим без подсказки.</dd>

    <dt><b><tt>-v</tt></b></dt>

    <dd>Информация о версии пакета.</dd>

    <dt><b><tt>var=value</tt></b></dt>

    <dd>Устанавливает глобальную переменную <code>var</code> в строку <code>&quot;value&quot;</code>.</dd>

    <dt><b><tt>filename</tt></b></dt>

    <dd>Выполняет файл <code>filename</code>.</dd>
  </dl>Когда вызван без параметров, <code>lua</code> ведет себя как <code>lua -v -i</code>, когда <code>stdin</code> представляет собой терминал, или аналогично <code>lua -</code> в противном случае.

  <p>Все параметры обработаны по порядку, за исключением <code>-c</code>. Например, обращение, подобное:</p>
  <pre>
$ lua -i a=test prog.lua
</pre>Сначала взаимодействует с пользователем до <code>EOF</code> в <code>stdin</code>, затем установит <code>a</code> в <code>&quot;test&quot;</code> и в заключение выполнит файл <code>prog.lua</code>. Здесь под <code>$</code> понимается подсказка оболочки. Ваша подсказка может быть иной.

  <p>Когда используется опция <tt>-f filename</tt>, все параметры в командной строке переданы программе Lua <code>filename</code> в таблице, названной <code>arg</code>. В этой таблице поле <code>n</code> получает индекс последнего параметра, а поле 0 получает <code>&quot;filename&quot;</code>. Например,</p>
  <pre>
$ lua a.lua -f b.lua t1 t3
</pre>интерпретатор сначала выполняет файл <tt>a.lua</tt>, затем создает таблицу:
  <pre>
arg = {&quot;t1&quot;, &quot;t3&quot;;  n = 2, [0] = &quot;b.lua&quot;}
</pre>а в заключение выполняет файл <tt>b.lua</tt>. <a name="getargs"></a>Автономный интерпретатор также обеспечивает функцию <code>getargs</code>, которая может использоваться, чтобы обратиться ко <em>всем</em> параметрам командной строки. Например, если Вы вызываете Lua строкой:
  <pre>
$ lua -c a b
</pre>то обращение к <code>getargs</code> в <code>a</code> или в <code>b</code> возвратит такую таблицу:
  <pre>
{[0] = &quot;lua&quot;, [1] = &quot;-c&quot;, [2] = &quot;a&quot;, [3] = &quot;b&quot;, n = 3}
</pre>

  <p>В интерактивном режиме может быть написана многострочная инструкция. Для этого надо заканчивать промежуточные строки наклонной чертой влево (<code>\</code>). Если глобальная переменная <a name="_PROMPT"><tt>_PROMPT</tt></a> определена как строка, то ее значение используется как подсказка. Следовательно, подсказка может быть изменена непосредственно в командной строке. Например:</p>
  <pre>
$ lua _PROMPT=&#39;myprompt&gt; &#39; -i
</pre>Или в программе Lua, назначая новое значение переменной <code>_PROMPT</code>.

  <p>В Unix Lua-скрипты могут быть переделаны в выполнимые программы, используя <code>chmod +x</code> и форму <code>#!</code> как в <code>#!/usr/local/bin/lua</code> или <code>#!/usr/local/bin/lua -f</code>, чтобы получить другие параметры. <a name="Acknowledgments"></a></p>

  <h1>10 Благодарности</h1>

  <p>Авторы пакета хотели бы поблагодарить CENPES/PETROBRAS, который, совместно с TeCGraf, использовал ранние версии этой системы и дал ценные комментарии. Авторы также хотели бы отблагодарить Carlos Henrique Levy за найденное имя для проекта. Lua на португальском означает луну. <a name="Incompatibilities"></a></p>

  <h1>11 Несовместимость с предыдущими версиями</h1>

  <p>Lua 4.0 представляет собой значительное изменение языка. Была проделана большая работа, чтобы избежать несовместимости с предыдущими общими версиями Lua, но некоторые различия нужно представлять. Есть список несовместимостей.</p>

  <h2>Несовместимости с <a name="version 3.2&lt;/h2&gt;">version 3.2</a></h2>

  <h3>Изменения в языке</h3>

  <ul>
    <li>Все прагмы (<code>$debug</code>, <code>$if</code>, ...) удалены.</li>

    <li><b>for</b>, <b>break</b> и <b>in</b> теперь зарезервированные слова.</li>

    <li>Методы тэгов уборки мусора для таблиц теперь устаревшие.</li>

    <li>Имеется теперь только один метод тэга для операторов порядка.</li>

    <li>Во вложенных обращениях к функции, подобно <code>f(g(x))</code>, <em>все</em> возвращаемые значения из <code>g</code> переданы как параметры <code>f</code>. Это случается только, когда <code>g</code> последний или единственный параметр для <code>f</code>.</li>

    <li>Предварительный компилятор может принимать, что некоторые операторы ассоциативны для оптимизации. Это может вызывать проблемы, если эти операторы имеют не ассоциативные методы тэгов.</li>

    <li>Старые прекомпилированные программы устарели, и должны быть перетранслирована.</li>
  </ul>

  <h3>Изменения в библиотеках</h3>

  <ul>
    <li>При пересечении таблицы с <code>next</code> или <code>foreach</code> таблица не может изменяться.</li>

    <li>Общие образцы чтения теперь устаревшие.</li>

    <li>Функции <code>rawgettable</code> и <code>rawsettable</code> теперь переименованы соответственно в <code>rawget</code> и <code>rawset</code>.</li>

    <li>Функции <code>foreachvar</code>, <code>nextvar</code>, <code>rawsetglobal</code> и <code>rawgetglobal</code> устаревшие. Вы можете получать их функциональные возможности, используя операции таблицы с таблицей глобальных переменных, возвращаемой <code>globals</code>.</li>

    <li><code>setglobal</code> и <code>sort</code> больше не возвращают значение. Вызов <code>type</code> больше не возвращает второе значение.</li>

    <li>Опция <code>p</code> в функции <code>call</code> устарела.</li>
  </ul>

  <h3>Изменения в API</h3>

  <ul>
    <li>API был полностью переделан. Это теперь полностью повторно используемо и намного более ясно.</li>

    <li>Отладочный API был полностью переделан.</li>
  </ul><a name="BNF"></a><a name="grammar"></a>

  <h1>12 Полный синтаксис Lua</h1><a name="grammar"></a>
  <pre>
chunk ::= {stat [`<b>;</b>&#39;]}
block ::= chunk
stat ::=  varlist1 `<b>=</b>&#39; explist1 <br>
          | functioncall <br>
          | <b>do</b> block <b>end</b> <br>
          | <b>while</b> exp1 <b>do</b> block <b>end</b> <br>
          | <b>repeat</b> block <b>until</b> exp1 <br>
          | <b>if</b> exp1 <b>then</b> block {<b>elseif</b>
            exp1 <b>then</b> block} [<b>else</b> block] <b>end</b><br>
          | <b>return</b> [explist1] <br>
          | <b>break</b> <br>
          | <b>for</b> `<b>name</b>&#39; `<b>=</b>&#39; exp1 `<b>,</b>&#39;
            exp1 [`<b>,</b>&#39; exp1] <b>do</b> block <b>end</b> <br>
          | <b>for</b> `<b>name</b>&#39; `<b>,</b>&#39; `<b>name</b>&#39;
            <b>in</b> exp1 <b>do</b> block <b>end</b> <br>
          | <b>function</b> funcname `<b>(</b>&#39; [parlist1] `<b>)</b>&#39;
            block <b>end</b> <br>
          | <b>local</b> declist [init] funcname ::= `<b>name</b>&#39;
            | `<b>name</b>&#39; `<b>.</b>&#39; `<b>name</b>&#39; | `<b>name</b>&#39;
            `<b>:</b>&#39; `<b>name</b>&#39;
varlist1 ::= var {`<b>,</b>&#39; var}
var ::= `<b>name</b>&#39; | varorfunc `<b>[</b>&#39; exp1 `<b>]</b>&#39;
        | varorfunc `<b>.</b>&#39; `<b>name</b>&#39;
varorfunc ::= var | functioncall
declist ::= `<b>name</b>&#39; {`<b>,</b>&#39; `<b>name</b>&#39;}
init ::= `<b>=</b>&#39; explist1
explist1 ::= {exp1 `<b>,</b>&#39;} exp
exp1 ::= exp
exp ::= <b>nil</b> | `<b>number</b>&#39; | `<b>literal</b>&#39; | var
        | function | upvalue <br>
 | functioncall | tableconstructor
        | `<b>(</b>&#39; exp `<b>)</b>&#39; | exp binop exp | unop exp
functioncall ::= varorfunc args | varorfunc `:&#39; `<b>name</b>&#39; args
args ::= `<b>(</b>&#39; [explist1] `<b>)</b>&#39; | tableconstructor
         | `<b>literal</b>&#39;
function ::= <b>function</b> `<b>(</b>&#39; [parlist1] `<b>)</b>&#39;
             block <b>end</b>
parlist1 ::= `<b>...</b>&#39; | `<b>name</b>&#39; {`<b>,</b>&#39;
             `<b>name</b>&#39;} [`<b>,</b>&#39; `<b>...</b>&#39;]
upvalue ::= `<b>%</b>&#39; `<b>name</b>&#39;
tableconstructor ::= `<b>{</b>&#39; fieldlist `<b>}</b>&#39;
fieldlist ::= lfieldlist | ffieldlist | lfieldlist `<b>;</b>&#39;
              ffieldlist | ffieldlist `<b>;</b>&#39; lfieldlist
lfieldlist ::= [lfieldlist1]
ffieldlist ::= [ffieldlist1]
lfieldlist1 ::= exp {`<b>,</b>&#39; exp} [`<b>,</b>&#39;]
ffieldlist1 ::= ffield {`<b>,</b>&#39; ffield} [`<b>,</b>&#39;]
ffield ::= `<b>[</b>&#39; exp `<b>]</b>&#39; `<b>=</b>&#39; exp
           | `<b>name</b>&#39; `<b>=</b>&#39; exp
binop ::= `<b>+</b>&#39; | `<b>-</b>&#39; | `<b>*</b>&#39; | `<b>/</b>&#39;
            | `<b>\^{ </b>&#39; | `<b>..</b>&#39; <br>
          | `<b>&lt;</b>&#39; | `<b>&lt;=</b>&#39; | `<b>&gt;</b>&#39;
            | `<b>&gt;=</b>&#39; | `<b>==</b>&#39; | `<b>\ { </b>&#39;=} <br>
          | <b>and</b> | <b>or</b>}
unop ::= `<b>-</b>&#39; | <b>not</b>
</pre>

  <h1>13 lua: интерпретатор языка Lua</h1>

  <h2>Синтаксис</h2><b>lua</b> [<i>arguments</i>]

  <h2>Описание</h2><b>lua</b> представляет собой автономный интерпретатор языка Lua. Он загружает и выполняет программы на Lua, как в текстовой исходной форме, так и в виде прекомпилированных модулей, созданных компилятором <b>luac</b>. <b>lua</b> может использоваться как пакетный интерпретатор, а также в интерактивном режиме.

  <p><i>arguments</i> могут быть параметрами, назначениями или именами файлов. Они будут обработаны слева направо.</p>

  <p>Параметры начинаются с тире (<b>-</b>) и описаны ниже.</p>

  <p>Назначение представляет собой параметр формы <b>a=b</b>, который назначает b глобальной переменной <b>a</b>. Обратите внимание, что никакие кавычки не нужны вокруг строки, если она не содержит пробелы или другие символы, специальные для оболочки. Вообще, Вы должны быть внимательны при использовании кавычек и пробелов в командной строке потому, что они обычно обрабатываются оболочкой непосредственно.</p>

  <p>Если параметр не является ни опцией, ни назначением, то это имя файла, который затем будет загружен и выполнен.</p>

  <p>Если никакие параметры не заданы, то принято <b>-v -i</b>, когда стандартный ввод представляет собой терминал, в противном случае используется <b>-</b>.</p>

  <h1>Опции</h1>

  <p><b>Тире (-)</b> загрузить стандартный ввод как файл, то есть не в интерактивном режиме, даже когда стандартный ввод является терминалом.</p>

  <p><b>-c</b> Закрыть Lua перед выходом.</p>

  <p><b>-e &quot;</b><i>stat&quot;</i> выполнить инструкцию <i>stat</i>. Вы должны цитировать <i>stat</i>, если она содержит пробелы или кавычки.</p>

  <p><b>-f &quot;</b><i>file&quot;</i> собрать все последующие параметры как строку в глобальную таблицу <b>arg</b>, а затем выполнить файл <i>file</i>. Параметры в <b>arg</b> начинаются с 0, который содержит строку file. Индекс последнего параметра сохранен в <b>arg.n</b>.</p>

  <p><b>-i</b> ввести интерактивный режим, показывая подсказку. В этом режиме <b>lua</b> читает строки из стандартного ввода и выполняет их как они читаются. Каждая строка должна содержать полную инструкцию. Чтобы записать инструкцию, охватывающую несколько строк, закончите каждую строку наклонной чертой влево (<b>\</b>). Показываемая подсказка представляет собой значение глобальной переменной <b>_PROMPT</b>, если это значение строка. Чтобы изменить подсказку, задайте нужное значение <b>_PROMPT</b>. Вы можете делать это после вызова интерпретатора или в командной строке с помощью <b>&quot;_PROMPT=\&#39;lua: \&#39;&quot;</b>. Обратите внимание на потребность в кавычках потому, что строка содержит пробел. Заданная по умолчанию подсказка: &gt;.</p>

  <p><b>-q</b> ввести интерактивный режим, но не показывая подсказку.</p>

  <p><b>-s</b><i>n</i> установить размер стека в n. Если представлено, это должно быть первой опцией. Обратите внимание, что <i>n</i> находится в том же самом параметре, что и <b>-s</b>. Например, чтобы определить размер стека в 2000, используйте <b>-s2000</b>.</p>

  <p><b>-v</b> вывести информацию о версии.</p>

  <h1>Также можно посмотреть</h1><b>luac</b>(1)<br>
  <a href="http://www.tecgraf.puc-rio.br/lua">http://www.tecgraf.puc-rio.br/lua</a>.

  <h1>Диагностика</h1>Сообщения пакета об ошибках должны быть самодостаточными.

  <h1>luac: компилятор Lua</h1>

  <h1>Синтаксис вызова</h1><b>luac</b> [<i>options</i>] [<i>filenames</i>]

  <h1>Описание</h1><b>luac</b> представляет собой компилятор Lua. Он транслирует программы, написанные на языке программирования Lua в двоичные файлы, которые могут быть загружены и выполнен с помощью <b>lua_dofile</b> в C или <b>dofile</b> в Lua.

  <p>Основные преимущества прекомпилированных программ: они быстрее при загрузке, исходный текст защищен от изменений пользователя и недоступно обнаружение ошибок синтаксиса.</p>

  <p>Прекомпиляция не подразумевает более быстрое выполнение потому, что в Lua блоки всегда компилируются в байт-код прежде, чем выполняются. <b>luac</b> просто позволяет этому байт-коду быть сохраненным в файле.</p>

  <p><b>luac</b> производит одиночный выходной файл, содержащий байт-код для всех заданных исходных файлов. По умолчанию выходной файл именован <b>luac.out</b>, но Вы можете изменять это опцией <b>-o</b>.</p>

  <p>Двоичные файлы, созданные <b>luac</b>, переносимы на любую архитектуру с тем же самым размером слова. Это означает, что двоичные файлы, созданные на 32-разрядной платформе (типа Intel) могут читаться без изменений на другой 32-разрядной платформе (типа Sparc), даже если порядок байт различен. С другой стороны, двоичные файлы, созданные на 16-разрядной платформе, не могут читаться на 32-разрядной платформе.</p>

  <p>В командной строке Вы можете смешивать текстовые файлы, содержащие код на Lua, и двоичные файлы, содержащие прекомпилированные блоки. Это полезно: чтобы объединить несколько прекомпилированных блоков даже с различных (но совместимых) платформ в один блок.</p>

  <p>Вы можете использовать <b>&quot;-&quot;</b>, чтобы указать <i>stdin</i> как исходный файл.</p>

  <p>Внутренний формат двоичных файлов, произведенных <b>luac</b>, может изменяться, когда выпущена новая версия Lua. Так что храните исходные файлы всех прекомпилированных программ Lua.</p>

  <h1>Опции</h1>

  <p>Параметры должны быть отделены друг от друга. <b>-l</b> производит распечатку компилируемого байт-кода для виртуальной машины Lua. Если никакие файлы не даны, то <b>luac</b> загружает <b>luac.out</b> и вносит в список его полное содержание.</p>

  <p><b>-o &quot;</b><i>file&quot;</i> выводит данные в <i>file</i> вместо значения по умолчанию <b>luac.out</b>. Выходной файл может быть исходным файл потому, что все файлы загружены прежде, чем выходной файл записан.</p>

  <p><b>-p</b> загружают файлы, но не генерируют никакой выходной файл. Использован главным образом для проверки синтаксиса или тестирования прекомпиляции: разрушенные файлы, вероятно, сгенерируют ошибки, когда будут загружены. Для полного теста целостности используйте опцию <b>-t</b>.</p>

  <p><b>-s</b> убирает отладочную информации перед записью выходного файла. Это экономит некоторое место в очень больших блоках, но если ошибки происходят при управлении ими, то сообщения об ошибках не смогут содержать полную информацию о том, что случилось.</p>

  <p><b>-t</b> выполняет полный тест целостности прекомпилированного кода. Код, который признает нормальным этот тест, полностью безопасен в том смысле, что это не будет разрывать интерпретатор. Однако, не имеется никакой гарантии, что такой код делает что-нибудь полезное. Если никакие файлы не заданы, то <b>luac</b> загружает <b>luac.out</b> и проверяет его содержимое.</p>

  <p><b>-v</b> выводит сведения о версии.</p>

  <h1>Файлы</h1>

  <p><b>luac.out</b> представляет собой заданный по умолчанию выходной файл</p>

  <h1>Также можно посмотреть</h1>

  <p><b>lua</b>(1)<br>
  <a href="http://www.tecgraf.puc-rio.br/lua">http://www.tecgraf.puc-rio.br/lua</a>.</p>

  <h1>Диагностика</h1>

  <p>Сообщения пакета об ошибках должны быть самодостаточными.</p>

  <h1>Авторы пакета</h1>
  <pre>
R. Ierusalimschy,
L. H. de Figueiredo и
W. Celes (<a href="mailto:lua@tecgraf.puc-rio.br">
lua@tecgraf.puc-rio.br</a>).
</pre>

  <h1>14 Установка языка LUA</h1>

  <p>Построение Lua на системах Unix очень просто:</p>

  <ul>
    <li>Отредактируйте файл <b>config</b>, чтобы соответствовать Вашей системе, если в этом есть необходимость.</li>

    <li>Выполните команду <b>make</b>.</li>

    <li>Если Вы хотите устанавливать Lua в &quot;официальное&quot; место в Вашей системе, то затем сделайте <b>make install</b>. Официальное место и способ устанавливать файлы определены в <b>config</b>. Вам, вероятно, придется регистрироваться как <b>root</b>, чтобы сделать это.</li>
  </ul>

  <p>Ниже приведены инструкции для пользователей систем Windows и Macintosh.</p>

  <h2>14.1 Что Вы получаете</h2>

  <p>Если <b>make</b> выполнилась без проблем, Вы получите:</p>

  <ul>
    <li>Интерпретатор <b>./bin/lua</b>, а также прекомпилятор <b>./bin/luac</b>.</li>

    <li>Набор библиотек в <b>./lib</b>.</li>

    <li>Включаемые файлы в <b>./include</b>.</li>
  </ul>

  <p>Это единственные каталоги, в которых Вы нуждаетесь для разработки.</p>

  <p>Man-страницы для <b>lua</b> и <b>luac</b> в nroff и html, а также справочное описание в html помещаются в <b>./doc</b>, некоторый типовой код в <b>./test</b>, а некоторые полезные дополнения в <b>./etc</b>. Вы не нуждаетесь в этих каталогах для разработки.</p>

  <p>Изучите также <b>README</b>-файлы в различных подкаталогах. Удобная отправная точка: <b>./doc/readme.html</b>.</p>

  <h2>14.2 Проблемы и некоторые решения</h2>

  <p>Если вызов <b>make</b> ничего хорошего не сделал, пожалуйста, сообщите на <a href="mailto:lua@tecgraf.puc-rio.br">lua@tecgraf.puc-rio.br</a>. Если Вы делаете изменения для <b>config</b> или в файлах <b>Makefile</b>, пожалуйста, пошлите их туда же.</p>

  <h2>14.3 Разделяемые библиотеки</h2>

  <p>Если Вы управляете Linux, сделайте <b>make so</b> после успешного выполнения <b>make</b>. Это создаст общедоступные библиотеки в <b>./lib</b>. Вероятно, лучше формировать общедоступные библиотеки прежде, чем выполнять <b>make install</b>.</p>

  <p>Если Вы хотите переделать интерпретатор и транслятор так, чтобы использовать общедоступные библиотеки, то выполните также <b>make sobin</b>.</p>

  <p>Вы, возможно, должны включить <b>lib</b> в системную переменную <b>LD_LIBRAY_PATH</b>, чтобы компоновать программы, которые используют общедоступные библиотеки, если Вы не помещаете их в официальные места с помощью <b>make install</b>.</p>

  <p>Формирование общедоступных библиотек в других системах подобно этому, но детали отличаются. Вы будете должны поправить несколько деталей в <b>Makefile</b> на верхнем уровне дерева кода.</p>

  <h2>14.4 Установка на Windows или Macintosh</h2>

  <p>Команды для формирования <b>Lua</b> на Mac или Windows-машине зависят от специфического компилятора, который Вы используете. Самый простой путь состоит в том, чтобы создать папку со всеми файлами <b>.c</b> и <b>.h</b>. Затем создайте проекты для основной библиотеки, стандартной библиотеки, интерпретатора и прекомпилятора следующим образом:</p>
  <pre>
core lib:     lapi.c lcode.c ldebug.c ldo.c lfunc.c lgc.c llex.c lmem.c
              lobject.c lparser.c lstate.c lstring.c ltable.c ltests.c
              ltm.c lundump.c lvm.c lzio.c
standard lib: lauxlib.c lbaselib.c ldblib.c liolib.c lmathlib.c lstrlib.c
interpreter:  core lib, standard lib, lua.c
compiler:     core lib, dump.c luac.c opt.c print.c stubs.c
</pre>

  <p>Конечно, чтобы использовать Lua как разделяемую библиотеку, Вы должны знать, как создавать и использовать библиотеки с Вашим компилятором и в Вашей операционной системе.</p>

  <h2>14.5 INSTALL для mysql 3.23.32</h2>

  <ul>
    <li>Скачайте LUA 4.0 patched для использования с mysql (оригинальный пакет не годится).</li>

    <li>Установите и откомпилируйте LUA 4.0, но не в том же самом каталоге, где и mysql. Я использую <b>/usr/src/lua</b> для LUA и <b>/usr/src/mysql</b> для MySQL.</li>

    <li>В дереве исходного кода mysql сделайте:
      <pre>
cd sql
tar zxf /download/mylua.tar.gz
cd ..
./configure --enable-assembler --prefix=/usr/local/mysql \
            --enable-assembler --with-mysqld-ldflags=&quot;-L/usr/src/lua/lib \
            -llua -llualib&quot;
</pre>
    </li>

    <li>Опробуйте скрипт примера:
      <pre>
mysql mysql
mysql&lt; SELECT user,host FROM user
              PROCEDURE(&quot;/usr/src/mysql/sql/count.lua&quot;)
</pre>
    </li>
  </ul>
</body>
</html>
